   1              		.cpu arm7tdmi-s
   2              		.eabi_attribute 27, 3
   3              		.fpu vfpv3-d16
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 2
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.code	16
  14              		.file	"main.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.TargetResetInit,"ax",%progbits
  19              		.align	2
  20              		.global	TargetResetInit
  21              		.code	16
  22              		.thumb_func
  24              	TargetResetInit:
  25              	.LFB0:
  26              		.file 1 "main.c"
   1:main.c        **** #include "LPC23xx.h"
   2:main.c        **** 
   3:main.c        **** /**************************************************************************************************
   4:main.c        **** 			Routine to set processor and peripheral clock 
   5:main.c        **** ***************************************************************************************************
   6:main.c        **** void  TargetResetInit(void)
   7:main.c        **** {
  27              		.loc 1 7 0
  28              		.cfi_startproc
  29 0000 80B5     		push	{r7, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 7, -8
  33              		.cfi_offset 14, -4
  34 0002 00AF     		add	r7, sp, #0
  35              	.LCFI1:
  36              		.cfi_def_cfa_register 7
   8:main.c        ****   // 72 Mhz Frequency
   9:main.c        ****   if ((PLLSTAT & 0x02000000) > 0)
  37              		.loc 1 9 0
  38 0004 3B4B     		ldr	r3, .L6
  39 0006 1A68     		ldr	r2, [r3]
  40 0008 8023     		mov	r3, #128
  41 000a 9B04     		lsl	r3, r3, #18
  42 000c 1340     		and	r3, r2
  43 000e 0BD0     		beq	.L2
  10:main.c        ****   {
  11:main.c        ****       /* If the PLL is already running   */
  12:main.c        ****       PLLCON  &= ~0x02;                         /* Disconnect the PLL                              
  44              		.loc 1 12 0
  45 0010 394B     		ldr	r3, .L6+4
  46 0012 394A     		ldr	r2, .L6+4
  47 0014 1268     		ldr	r2, [r2]
  48 0016 0221     		mov	r1, #2
  49 0018 8A43     		bic	r2, r1
  50 001a 1A60     		str	r2, [r3]
  13:main.c        ****       PLLFEED  =  0xAA;                        	/* PLL register update sequence, 0xAA, 0x55        
  51              		.loc 1 13 0
  52 001c 374B     		ldr	r3, .L6+8
  53 001e AA22     		mov	r2, #170
  54 0020 1A60     		str	r2, [r3]
  14:main.c        ****       PLLFEED  =  0x55;
  55              		.loc 1 14 0
  56 0022 364B     		ldr	r3, .L6+8
  57 0024 5522     		mov	r2, #85
  58 0026 1A60     		str	r2, [r3]
  59              	.L2:
  15:main.c        ****   }
  16:main.c        ****   PLLCON   &= ~0x01;                            /* Disable the PLL                                 
  60              		.loc 1 16 0
  61 0028 334B     		ldr	r3, .L6+4
  62 002a 334A     		ldr	r2, .L6+4
  63 002c 1268     		ldr	r2, [r2]
  64 002e 0121     		mov	r1, #1
  65 0030 8A43     		bic	r2, r1
  66 0032 1A60     		str	r2, [r3]
  17:main.c        ****   PLLFEED   =  0xAA;                           	/* PLL register update sequence, 0xAA, 0x55        
  67              		.loc 1 17 0
  68 0034 314B     		ldr	r3, .L6+8
  69 0036 AA22     		mov	r2, #170
  70 0038 1A60     		str	r2, [r3]
  18:main.c        ****   PLLFEED   =  0x55;
  71              		.loc 1 18 0
  72 003a 304B     		ldr	r3, .L6+8
  73 003c 5522     		mov	r2, #85
  74 003e 1A60     		str	r2, [r3]
  19:main.c        ****   SCS      &= ~0x10;                         	/* OSCRANGE = 0, Main OSC is between 1 and 20 Mhz    
  75              		.loc 1 19 0
  76 0040 2F4B     		ldr	r3, .L6+12
  77 0042 2F4A     		ldr	r2, .L6+12
  78 0044 1268     		ldr	r2, [r2]
  79 0046 1021     		mov	r1, #16
  80 0048 8A43     		bic	r2, r1
  81 004a 1A60     		str	r2, [r3]
  20:main.c        ****   SCS      |=  0x20;                         	/* OSCEN = 1, Enable the main oscillator             
  82              		.loc 1 20 0
  83 004c 2C4B     		ldr	r3, .L6+12
  84 004e 2C4A     		ldr	r2, .L6+12
  85 0050 1268     		ldr	r2, [r2]
  86 0052 2021     		mov	r1, #32
  87 0054 0A43     		orr	r2, r1
  88 0056 1A60     		str	r2, [r3]
  21:main.c        ****   while ((SCS &  0x40) == 0);
  89              		.loc 1 21 0
  90 0058 C046     		mov	r8, r8
  91              	.L3:
  92              		.loc 1 21 0 is_stmt 0 discriminator 1
  93 005a 294B     		ldr	r3, .L6+12
  94 005c 1A68     		ldr	r2, [r3]
  95 005e 4023     		mov	r3, #64
  96 0060 1340     		and	r3, r2
  97 0062 FAD0     		beq	.L3
  22:main.c        ****   CLKSRCSEL = 0x01;                         	/* Select main OSC, 12MHz, as the PLL clock source    
  98              		.loc 1 22 0 is_stmt 1
  99 0064 274B     		ldr	r3, .L6+16
 100 0066 0122     		mov	r2, #1
 101 0068 1A60     		str	r2, [r3]
  23:main.c        ****   PLLCFG    = (24 << 0) | (1 << 16);         	/* Configure the PLL multiplier and divider          
 102              		.loc 1 23 0
 103 006a 274B     		ldr	r3, .L6+20
 104 006c 274A     		ldr	r2, .L6+24
 105 006e 1A60     		str	r2, [r3]
  24:main.c        ****   PLLFEED   = 0xAA;                         	/* PLL register update sequence, 0xAA, 0x55           
 106              		.loc 1 24 0
 107 0070 224B     		ldr	r3, .L6+8
 108 0072 AA22     		mov	r2, #170
 109 0074 1A60     		str	r2, [r3]
  25:main.c        ****   PLLFEED   = 0x55;
 110              		.loc 1 25 0
 111 0076 214B     		ldr	r3, .L6+8
 112 0078 5522     		mov	r2, #85
 113 007a 1A60     		str	r2, [r3]
  26:main.c        ****   PLLCON   |= 0x01;                        		/* Enable the PLL                                     
 114              		.loc 1 26 0
 115 007c 1E4B     		ldr	r3, .L6+4
 116 007e 1E4A     		ldr	r2, .L6+4
 117 0080 1268     		ldr	r2, [r2]
 118 0082 0121     		mov	r1, #1
 119 0084 0A43     		orr	r2, r1
 120 0086 1A60     		str	r2, [r3]
  27:main.c        ****   PLLFEED   = 0xAA;                        		/* PLL register update sequence, 0xAA, 0x55           
 121              		.loc 1 27 0
 122 0088 1C4B     		ldr	r3, .L6+8
 123 008a AA22     		mov	r2, #170
 124 008c 1A60     		str	r2, [r3]
  28:main.c        ****   PLLFEED   = 0x55;
 125              		.loc 1 28 0
 126 008e 1B4B     		ldr	r3, .L6+8
 127 0090 5522     		mov	r2, #85
 128 0092 1A60     		str	r2, [r3]
  29:main.c        ****   CCLKCFG   = 3;                        		/* Configure the ARM Core Processor clock divider        
 129              		.loc 1 29 0
 130 0094 1E4B     		ldr	r3, .L6+28
 131 0096 0322     		mov	r2, #3
 132 0098 1A60     		str	r2, [r3]
  30:main.c        ****   USBCLKCFG = 5;                    			/* Configure the USB clock divider                          
 133              		.loc 1 30 0
 134 009a 1E4B     		ldr	r3, .L6+32
 135 009c 0522     		mov	r2, #5
 136 009e 1A60     		str	r2, [r3]
  31:main.c        ****   while ((PLLSTAT & 0x04000000) == 0);  
 137              		.loc 1 31 0
 138 00a0 C046     		mov	r8, r8
 139              	.L4:
 140              		.loc 1 31 0 is_stmt 0 discriminator 1
 141 00a2 144B     		ldr	r3, .L6
 142 00a4 1A68     		ldr	r2, [r3]
 143 00a6 8023     		mov	r3, #128
 144 00a8 DB04     		lsl	r3, r3, #19
 145 00aa 1340     		and	r3, r2
 146 00ac F9D0     		beq	.L4
  32:main.c        ****   PCLKSEL0  = 0xAAAAAAAA;                     	/* Set peripheral clocks to be half of main clock   
 147              		.loc 1 32 0 is_stmt 1
 148 00ae 1A4B     		ldr	r3, .L6+36
 149 00b0 1A4A     		ldr	r2, .L6+40
 150 00b2 1A60     		str	r2, [r3]
  33:main.c        ****   PCLKSEL1  = 0x22AAA8AA;
 151              		.loc 1 33 0
 152 00b4 1A4B     		ldr	r3, .L6+44
 153 00b6 1B4A     		ldr	r2, .L6+48
 154 00b8 1A60     		str	r2, [r3]
  34:main.c        ****   PLLCON   |= 0x02;                         	/* Connect the PLL. The PLL is now the active clock so
 155              		.loc 1 34 0
 156 00ba 0F4B     		ldr	r3, .L6+4
 157 00bc 0E4A     		ldr	r2, .L6+4
 158 00be 1268     		ldr	r2, [r2]
 159 00c0 0221     		mov	r1, #2
 160 00c2 0A43     		orr	r2, r1
 161 00c4 1A60     		str	r2, [r3]
  35:main.c        ****   PLLFEED   = 0xAA;                          	/* PLL register update sequence, 0xAA, 0x55          
 162              		.loc 1 35 0
 163 00c6 0D4B     		ldr	r3, .L6+8
 164 00c8 AA22     		mov	r2, #170
 165 00ca 1A60     		str	r2, [r3]
  36:main.c        ****   PLLFEED   = 0x55;
 166              		.loc 1 36 0
 167 00cc 0B4B     		ldr	r3, .L6+8
 168 00ce 5522     		mov	r2, #85
 169 00d0 1A60     		str	r2, [r3]
  37:main.c        ****   while ((PLLSTAT & 0x02000000) == 0);  
 170              		.loc 1 37 0
 171 00d2 C046     		mov	r8, r8
 172              	.L5:
 173              		.loc 1 37 0 is_stmt 0 discriminator 1
 174 00d4 074B     		ldr	r3, .L6
 175 00d6 1A68     		ldr	r2, [r3]
 176 00d8 8023     		mov	r3, #128
 177 00da 9B04     		lsl	r3, r3, #18
 178 00dc 1340     		and	r3, r2
 179 00de F9D0     		beq	.L5
  38:main.c        ****   PCLKSEL0 = 0x55555555;  		     			/* PCLK is the same as CCLK */
 180              		.loc 1 38 0 is_stmt 1
 181 00e0 0D4B     		ldr	r3, .L6+36
 182 00e2 114A     		ldr	r2, .L6+52
 183 00e4 1A60     		str	r2, [r3]
  39:main.c        ****   PCLKSEL1 = 0x55555555;  
 184              		.loc 1 39 0
 185 00e6 0E4B     		ldr	r3, .L6+44
 186 00e8 0F4A     		ldr	r2, .L6+52
 187 00ea 1A60     		str	r2, [r3]
  40:main.c        **** }
 188              		.loc 1 40 0
 189 00ec BD46     		mov	sp, r7
 190              		@ sp needed for prologue
 191 00ee 80BC     		pop	{r7}
 192 00f0 01BC     		pop	{r0}
 193 00f2 0047     		bx	r0
 194              	.L7:
 195              		.align	2
 196              	.L6:
 197 00f4 88C01FE0 		.word	-534790008
 198 00f8 80C01FE0 		.word	-534790016
 199 00fc 8CC01FE0 		.word	-534790004
 200 0100 A0C11FE0 		.word	-534789728
 201 0104 0CC11FE0 		.word	-534789876
 202 0108 84C01FE0 		.word	-534790012
 203 010c 18000100 		.word	65560
 204 0110 04C11FE0 		.word	-534789884
 205 0114 08C11FE0 		.word	-534789880
 206 0118 A8C11FE0 		.word	-534789720
 207 011c AAAAAAAA 		.word	-1431655766
 208 0120 ACC11FE0 		.word	-534789716
 209 0124 AAA8AA22 		.word	581609642
 210 0128 55555555 		.word	1431655765
 211              		.cfi_endproc
 212              	.LFE0:
 214              		.section	.text.delay,"ax",%progbits
 215              		.align	2
 216              		.code	16
 217              		.thumb_func
 219              	delay:
 220              	.LFB1:
  41:main.c        **** // delay routine 
  42:main.c        **** static void delay(void)
  43:main.c        **** {
 221              		.loc 1 43 0
 222              		.cfi_startproc
 223 0000 80B5     		push	{r7, lr}
 224              	.LCFI2:
 225              		.cfi_def_cfa_offset 8
 226              		.cfi_offset 7, -8
 227              		.cfi_offset 14, -4
 228 0002 82B0     		sub	sp, sp, #8
 229              	.LCFI3:
 230              		.cfi_def_cfa_offset 16
 231 0004 00AF     		add	r7, sp, #0
 232              	.LCFI4:
 233              		.cfi_def_cfa_register 7
  44:main.c        **** 	unsigned int i,j;
  45:main.c        **** 	for(i=0;i<0xff;i++)
 234              		.loc 1 45 0
 235 0006 0023     		mov	r3, #0
 236 0008 3B60     		str	r3, [r7]
 237 000a 0CE0     		b	.L9
 238              	.L12:
  46:main.c        **** 	 for(j=0;j<0x3ff;j++);
 239              		.loc 1 46 0
 240 000c 0023     		mov	r3, #0
 241 000e 7B60     		str	r3, [r7, #4]
 242 0010 02E0     		b	.L10
 243              	.L11:
 244              		.loc 1 46 0 is_stmt 0 discriminator 2
 245 0012 7B68     		ldr	r3, [r7, #4]
 246 0014 0133     		add	r3, r3, #1
 247 0016 7B60     		str	r3, [r7, #4]
 248              	.L10:
 249              		.loc 1 46 0 discriminator 1
 250 0018 7A68     		ldr	r2, [r7, #4]
 251 001a 074B     		ldr	r3, .L13
 252 001c 9A42     		cmp	r2, r3
 253 001e F8D9     		bls	.L11
  45:main.c        **** 	for(i=0;i<0xff;i++)
 254              		.loc 1 45 0 is_stmt 1
 255 0020 3B68     		ldr	r3, [r7]
 256 0022 0133     		add	r3, r3, #1
 257 0024 3B60     		str	r3, [r7]
 258              	.L9:
  45:main.c        **** 	for(i=0;i<0xff;i++)
 259              		.loc 1 45 0 is_stmt 0 discriminator 1
 260 0026 3B68     		ldr	r3, [r7]
 261 0028 FE2B     		cmp	r3, #254
 262 002a EFD9     		bls	.L12
  47:main.c        **** }
 263              		.loc 1 47 0 is_stmt 1
 264 002c BD46     		mov	sp, r7
 265 002e 02B0     		add	sp, sp, #8
 266              		@ sp needed for prologue
 267 0030 80BC     		pop	{r7}
 268 0032 01BC     		pop	{r0}
 269 0034 0047     		bx	r0
 270              	.L14:
 271 0036 C046     		.align	2
 272              	.L13:
 273 0038 FE030000 		.word	1022
 274              		.cfi_endproc
 275              	.LFE1:
 277              		.section	.text.rotate,"ax",%progbits
 278              		.align	2
 279              		.global	rotate
 280              		.code	16
 281              		.thumb_func
 283              	rotate:
 284              	.LFB2:
  48:main.c        **** 
  49:main.c        **** void rotate(void)
  50:main.c        **** {
 285              		.loc 1 50 0
 286              		.cfi_startproc
 287 0000 80B5     		push	{r7, lr}
 288              	.LCFI5:
 289              		.cfi_def_cfa_offset 8
 290              		.cfi_offset 7, -8
 291              		.cfi_offset 14, -4
 292 0002 82B0     		sub	sp, sp, #8
 293              	.LCFI6:
 294              		.cfi_def_cfa_offset 16
 295 0004 00AF     		add	r7, sp, #0
 296              	.LCFI7:
 297              		.cfi_def_cfa_register 7
  51:main.c        **** 	FIO3DIR	= 0xFF;
 298              		.loc 1 51 0
 299 0006 0F4B     		ldr	r3, .L19
 300 0008 FF22     		mov	r2, #255
 301 000a 1A60     		str	r2, [r3]
  52:main.c        **** 	FIO3PIN	= 0x01; 		// Our initial pin configuration
 302              		.loc 1 52 0
 303 000c 0E4B     		ldr	r3, .L19+4
 304 000e 0122     		mov	r2, #1
 305 0010 1A60     		str	r2, [r3]
  53:main.c        **** 	int i;
  54:main.c        **** 	int tempnum = 0x01;
 306              		.loc 1 54 0
 307 0012 0123     		mov	r3, #1
 308 0014 7B60     		str	r3, [r7, #4]
 309              	.L18:
  55:main.c        **** 	while(1)
  56:main.c        **** 	{
  57:main.c        **** 		tempnum = 0x01; 
 310              		.loc 1 57 0
 311 0016 0123     		mov	r3, #1
 312 0018 7B60     		str	r3, [r7, #4]
  58:main.c        **** 		for (i = 0; i < 8; i++ )
 313              		.loc 1 58 0
 314 001a 0023     		mov	r3, #0
 315 001c 3B60     		str	r3, [r7]
 316 001e 0DE0     		b	.L16
 317              	.L17:
  59:main.c        **** 		{
  60:main.c        **** 			delay();
 318              		.loc 1 60 0 discriminator 2
 319 0020 FFF7FEFF 		bl	delay
  61:main.c        **** 			delay();
 320              		.loc 1 61 0 discriminator 2
 321 0024 FFF7FEFF 		bl	delay
  62:main.c        **** 			FIO3PIN = tempnum << i;
 322              		.loc 1 62 0 discriminator 2
 323 0028 074B     		ldr	r3, .L19+4
 324 002a 7968     		ldr	r1, [r7, #4]
 325 002c 3A68     		ldr	r2, [r7]
 326 002e 081C     		mov	r0, r1
 327 0030 9040     		lsl	r0, r0, r2
 328 0032 021C     		mov	r2, r0
 329 0034 1A60     		str	r2, [r3]
  58:main.c        **** 		for (i = 0; i < 8; i++ )
 330              		.loc 1 58 0 discriminator 2
 331 0036 3B68     		ldr	r3, [r7]
 332 0038 0133     		add	r3, r3, #1
 333 003a 3B60     		str	r3, [r7]
 334              	.L16:
  58:main.c        **** 		for (i = 0; i < 8; i++ )
 335              		.loc 1 58 0 is_stmt 0 discriminator 1
 336 003c 3B68     		ldr	r3, [r7]
 337 003e 072B     		cmp	r3, #7
 338 0040 EEDD     		ble	.L17
  63:main.c        **** 		}
  64:main.c        **** 			
  65:main.c        **** 	}
 339              		.loc 1 65 0 is_stmt 1
 340 0042 E8E7     		b	.L18
 341              	.L20:
 342              		.align	2
 343              	.L19:
 344 0044 60C0FF3F 		.word	1073725536
 345 0048 74C0FF3F 		.word	1073725556
 346              		.cfi_endproc
 347              	.LFE2:
 349              		.section	.text.rotate1,"ax",%progbits
 350              		.align	2
 351              		.global	rotate1
 352              		.code	16
 353              		.thumb_func
 355              	rotate1:
 356              	.LFB3:
  66:main.c        **** }
  67:main.c        **** void rotate1(void)
  68:main.c        **** {
 357              		.loc 1 68 0
 358              		.cfi_startproc
 359 0000 80B5     		push	{r7, lr}
 360              	.LCFI8:
 361              		.cfi_def_cfa_offset 8
 362              		.cfi_offset 7, -8
 363              		.cfi_offset 14, -4
 364 0002 82B0     		sub	sp, sp, #8
 365              	.LCFI9:
 366              		.cfi_def_cfa_offset 16
 367 0004 00AF     		add	r7, sp, #0
 368              	.LCFI10:
 369              		.cfi_def_cfa_register 7
  69:main.c        **** 	FIO3DIR	= 0xFF;
 370              		.loc 1 69 0
 371 0006 144B     		ldr	r3, .L25
 372 0008 FF22     		mov	r2, #255
 373 000a 1A60     		str	r2, [r3]
  70:main.c        **** 	FIO3PIN	= 0x01; 		// Our initial pin configuration
 374              		.loc 1 70 0
 375 000c 134B     		ldr	r3, .L25+4
 376 000e 0122     		mov	r2, #1
 377 0010 1A60     		str	r2, [r3]
  71:main.c        **** 	int i = 0;
 378              		.loc 1 71 0
 379 0012 0023     		mov	r3, #0
 380 0014 3B60     		str	r3, [r7]
  72:main.c        **** 	int tempnum = 0x80;
 381              		.loc 1 72 0
 382 0016 8023     		mov	r3, #128
 383 0018 7B60     		str	r3, [r7, #4]
 384 001a 00E0     		b	.L23
 385              	.L24:
  73:main.c        **** 	while(1)
  74:main.c        **** 	{
  75:main.c        **** 		FIO3PIN	= tempnum;
  76:main.c        **** 		
  77:main.c        **** 		delay();
  78:main.c        **** 		delay();
  79:main.c        **** 		tempnum = (0x80 >> i) + (1<<i) ;
  80:main.c        **** 		i += 1;
  81:main.c        **** 		if(tempnum==0)
  82:main.c        **** 		{
  83:main.c        **** 			i = 0;
  84:main.c        **** 			tempnum = 0x80;
  85:main.c        **** 		}
  86:main.c        **** 					
  87:main.c        **** 	}
 386              		.loc 1 87 0
 387 001c C046     		mov	r8, r8
 388              	.L23:
  75:main.c        **** 		FIO3PIN	= tempnum;
 389              		.loc 1 75 0
 390 001e 0F4B     		ldr	r3, .L25+4
 391 0020 7A68     		ldr	r2, [r7, #4]
 392 0022 1A60     		str	r2, [r3]
  77:main.c        **** 		delay();
 393              		.loc 1 77 0
 394 0024 FFF7FEFF 		bl	delay
  78:main.c        **** 		delay();
 395              		.loc 1 78 0
 396 0028 FFF7FEFF 		bl	delay
  79:main.c        **** 		tempnum = (0x80 >> i) + (1<<i) ;
 397              		.loc 1 79 0
 398 002c 8022     		mov	r2, #128
 399 002e 3B68     		ldr	r3, [r7]
 400 0030 1A41     		asr	r2, r2, r3
 401 0032 0121     		mov	r1, #1
 402 0034 3B68     		ldr	r3, [r7]
 403 0036 081C     		mov	r0, r1
 404 0038 9840     		lsl	r0, r0, r3
 405 003a 031C     		mov	r3, r0
 406 003c D318     		add	r3, r2, r3
 407 003e 7B60     		str	r3, [r7, #4]
  80:main.c        **** 		i += 1;
 408              		.loc 1 80 0
 409 0040 3B68     		ldr	r3, [r7]
 410 0042 0133     		add	r3, r3, #1
 411 0044 3B60     		str	r3, [r7]
  81:main.c        **** 		if(tempnum==0)
 412              		.loc 1 81 0
 413 0046 7B68     		ldr	r3, [r7, #4]
 414 0048 002B     		cmp	r3, #0
 415 004a E7D1     		bne	.L24
  83:main.c        **** 			i = 0;
 416              		.loc 1 83 0
 417 004c 0023     		mov	r3, #0
 418 004e 3B60     		str	r3, [r7]
  84:main.c        **** 			tempnum = 0x80;
 419              		.loc 1 84 0
 420 0050 8023     		mov	r3, #128
 421 0052 7B60     		str	r3, [r7, #4]
 422              		.loc 1 87 0
 423 0054 E2E7     		b	.L24
 424              	.L26:
 425 0056 C046     		.align	2
 426              	.L25:
 427 0058 60C0FF3F 		.word	1073725536
 428 005c 74C0FF3F 		.word	1073725556
 429              		.cfi_endproc
 430              	.LFE3:
 432              		.section	.text.four_bit_add,"ax",%progbits
 433              		.align	2
 434              		.global	four_bit_add
 435              		.code	16
 436              		.thumb_func
 438              	four_bit_add:
 439              	.LFB4:
  88:main.c        **** }
  89:main.c        **** 
  90:main.c        **** void four_bit_add(void)
  91:main.c        **** {
 440              		.loc 1 91 0
 441              		.cfi_startproc
 442 0000 80B5     		push	{r7, lr}
 443              	.LCFI11:
 444              		.cfi_def_cfa_offset 8
 445              		.cfi_offset 7, -8
 446              		.cfi_offset 14, -4
 447 0002 86B0     		sub	sp, sp, #24
 448              	.LCFI12:
 449              		.cfi_def_cfa_offset 32
 450 0004 00AF     		add	r7, sp, #0
 451              	.LCFI13:
 452              		.cfi_def_cfa_register 7
  92:main.c        **** 	FIO3DIR = 0xFF;
 453              		.loc 1 92 0
 454 0006 124B     		ldr	r3, .L30
 455 0008 FF22     		mov	r2, #255
 456 000a 1A60     		str	r2, [r3]
  93:main.c        **** 	FIO4DIR = 0x00;
 457              		.loc 1 93 0
 458 000c 114B     		ldr	r3, .L30+4
 459 000e 0022     		mov	r2, #0
 460 0010 1A60     		str	r2, [r3]
  94:main.c        **** 	
  95:main.c        **** 	int num1, num2, result, mask1, mask2;
  96:main.c        **** 	mask1 = 0x0f;
 461              		.loc 1 96 0
 462 0012 0F23     		mov	r3, #15
 463 0014 BB60     		str	r3, [r7, #8]
  97:main.c        **** 	mask2 = 0xf0;
 464              		.loc 1 97 0
 465 0016 F023     		mov	r3, #240
 466 0018 FB60     		str	r3, [r7, #12]
 467              	.L29:
  98:main.c        **** 	
  99:main.c        **** 	while(1)
 100:main.c        **** 	{
 101:main.c        **** 		num1 = mask1 & FIO4PIN;
 468              		.loc 1 101 0
 469 001a 0F4B     		ldr	r3, .L30+8
 470 001c 1B68     		ldr	r3, [r3]
 471 001e BA68     		ldr	r2, [r7, #8]
 472 0020 1340     		and	r3, r2
 473 0022 3B61     		str	r3, [r7, #16]
 102:main.c        **** 		num2 = mask2 & FIO4PIN;
 474              		.loc 1 102 0
 475 0024 0C4B     		ldr	r3, .L30+8
 476 0026 1B68     		ldr	r3, [r3]
 477 0028 FA68     		ldr	r2, [r7, #12]
 478 002a 1340     		and	r3, r2
 479 002c 7B61     		str	r3, [r7, #20]
 103:main.c        **** 		num2 = num2 >> 4;
 480              		.loc 1 103 0
 481 002e 7B69     		ldr	r3, [r7, #20]
 482 0030 1B11     		asr	r3, r3, #4
 483 0032 7B61     		str	r3, [r7, #20]
 104:main.c        **** 		result = num1 + num2;
 484              		.loc 1 104 0
 485 0034 3A69     		ldr	r2, [r7, #16]
 486 0036 7B69     		ldr	r3, [r7, #20]
 487 0038 D318     		add	r3, r2, r3
 488 003a 7B60     		str	r3, [r7, #4]
 105:main.c        **** 		if (result > 9)
 489              		.loc 1 105 0
 490 003c 7B68     		ldr	r3, [r7, #4]
 491 003e 092B     		cmp	r3, #9
 492 0040 02DD     		ble	.L28
 106:main.c        **** 			result += 6;
 493              		.loc 1 106 0
 494 0042 7B68     		ldr	r3, [r7, #4]
 495 0044 0633     		add	r3, r3, #6
 496 0046 7B60     		str	r3, [r7, #4]
 497              	.L28:
 107:main.c        **** 		FIO3PIN = result;
 498              		.loc 1 107 0
 499 0048 044B     		ldr	r3, .L30+12
 500 004a 7A68     		ldr	r2, [r7, #4]
 501 004c 1A60     		str	r2, [r3]
 108:main.c        **** 	}
 502              		.loc 1 108 0
 503 004e E4E7     		b	.L29
 504              	.L31:
 505              		.align	2
 506              	.L30:
 507 0050 60C0FF3F 		.word	1073725536
 508 0054 80C0FF3F 		.word	1073725568
 509 0058 94C0FF3F 		.word	1073725588
 510 005c 74C0FF3F 		.word	1073725556
 511              		.cfi_endproc
 512              	.LFE4:
 514              		.section	.text.reflect,"ax",%progbits
 515              		.align	2
 516              		.global	reflect
 517              		.code	16
 518              		.thumb_func
 520              	reflect:
 521              	.LFB5:
 109:main.c        **** }
 110:main.c        **** 
 111:main.c        **** void reflect(void)
 112:main.c        **** {
 522              		.loc 1 112 0
 523              		.cfi_startproc
 524 0000 80B5     		push	{r7, lr}
 525              	.LCFI14:
 526              		.cfi_def_cfa_offset 8
 527              		.cfi_offset 7, -8
 528              		.cfi_offset 14, -4
 529 0002 00AF     		add	r7, sp, #0
 530              	.LCFI15:
 531              		.cfi_def_cfa_register 7
 113:main.c        **** 	FIO3DIR = 0xff;
 532              		.loc 1 113 0
 533 0004 054B     		ldr	r3, .L34
 534 0006 FF22     		mov	r2, #255
 535 0008 1A60     		str	r2, [r3]
 114:main.c        **** 	FIO4DIR = 0x00;
 536              		.loc 1 114 0
 537 000a 054B     		ldr	r3, .L34+4
 538 000c 0022     		mov	r2, #0
 539 000e 1A60     		str	r2, [r3]
 540              	.L33:
 115:main.c        **** 	while(1)
 116:main.c        **** 		FIO3PIN = ~FIO4PIN;
 541              		.loc 1 116 0 discriminator 1
 542 0010 044B     		ldr	r3, .L34+8
 543 0012 054A     		ldr	r2, .L34+12
 544 0014 1268     		ldr	r2, [r2]
 545 0016 D243     		mvn	r2, r2
 546 0018 1A60     		str	r2, [r3]
 547 001a F9E7     		b	.L33
 548              	.L35:
 549              		.align	2
 550              	.L34:
 551 001c 60C0FF3F 		.word	1073725536
 552 0020 80C0FF3F 		.word	1073725568
 553 0024 74C0FF3F 		.word	1073725556
 554 0028 94C0FF3F 		.word	1073725588
 555              		.cfi_endproc
 556              	.LFE5:
 558              		.section	.text.blink,"ax",%progbits
 559              		.align	2
 560              		.global	blink
 561              		.code	16
 562              		.thumb_func
 564              	blink:
 565              	.LFB6:
 117:main.c        **** }
 118:main.c        **** 
 119:main.c        **** void blink(void)
 120:main.c        **** {
 566              		.loc 1 120 0
 567              		.cfi_startproc
 568 0000 80B5     		push	{r7, lr}
 569              	.LCFI16:
 570              		.cfi_def_cfa_offset 8
 571              		.cfi_offset 7, -8
 572              		.cfi_offset 14, -4
 573 0002 00AF     		add	r7, sp, #0
 574              	.LCFI17:
 575              		.cfi_def_cfa_register 7
 576              	.L37:
 121:main.c        **** 	while(1)
 122:main.c        **** 	{
 123:main.c        **** 		delay();
 577              		.loc 1 123 0 discriminator 1
 578 0004 FFF7FEFF 		bl	delay
 124:main.c        **** 		FIO3PIN = 0x00;
 579              		.loc 1 124 0 discriminator 1
 580 0008 044B     		ldr	r3, .L38
 581 000a 0022     		mov	r2, #0
 582 000c 1A60     		str	r2, [r3]
 125:main.c        **** 		delay();
 583              		.loc 1 125 0 discriminator 1
 584 000e FFF7FEFF 		bl	delay
 126:main.c        **** 		FIO3PIN = 0x01;
 585              		.loc 1 126 0 discriminator 1
 586 0012 024B     		ldr	r3, .L38
 587 0014 0122     		mov	r2, #1
 588 0016 1A60     		str	r2, [r3]
 127:main.c        **** 	}
 589              		.loc 1 127 0 discriminator 1
 590 0018 F4E7     		b	.L37
 591              	.L39:
 592 001a C046     		.align	2
 593              	.L38:
 594 001c 74C0FF3F 		.word	1073725556
 595              		.cfi_endproc
 596              	.LFE6:
 598              		.section	.text.bin2gry,"ax",%progbits
 599              		.align	2
 600              		.global	bin2gry
 601              		.code	16
 602              		.thumb_func
 604              	bin2gry:
 605              	.LFB7:
 128:main.c        **** }
 129:main.c        **** 
 130:main.c        **** void bin2gry(void)
 131:main.c        **** {
 606              		.loc 1 131 0
 607              		.cfi_startproc
 608 0000 80B5     		push	{r7, lr}
 609              	.LCFI18:
 610              		.cfi_def_cfa_offset 8
 611              		.cfi_offset 7, -8
 612              		.cfi_offset 14, -4
 613 0002 82B0     		sub	sp, sp, #8
 614              	.LCFI19:
 615              		.cfi_def_cfa_offset 16
 616 0004 00AF     		add	r7, sp, #0
 617              	.LCFI20:
 618              		.cfi_def_cfa_register 7
 132:main.c        **** 	FIO3PIN	= 0xFF;
 619              		.loc 1 132 0
 620 0006 094B     		ldr	r3, .L42
 621 0008 FF22     		mov	r2, #255
 622 000a 1A60     		str	r2, [r3]
 133:main.c        **** 	FIO4PIN	= 0x00;
 623              		.loc 1 133 0
 624 000c 084B     		ldr	r3, .L42+4
 625 000e 0022     		mov	r2, #0
 626 0010 1A60     		str	r2, [r3]
 134:main.c        **** 	int tempnum = 0x00;
 627              		.loc 1 134 0
 628 0012 0023     		mov	r3, #0
 629 0014 7B60     		str	r3, [r7, #4]
 630              	.L41:
 135:main.c        **** 	
 136:main.c        **** 	while(1)
 137:main.c        **** 	{
 138:main.c        **** 		tempnum = FIO4PIN;
 631              		.loc 1 138 0 discriminator 1
 632 0016 064B     		ldr	r3, .L42+4
 633 0018 1B68     		ldr	r3, [r3]
 634 001a 7B60     		str	r3, [r7, #4]
 139:main.c        **** 		FIO3PIN = tempnum ^ (tempnum >> 1);
 635              		.loc 1 139 0 discriminator 1
 636 001c 034B     		ldr	r3, .L42
 637 001e 7A68     		ldr	r2, [r7, #4]
 638 0020 5110     		asr	r1, r2, #1
 639 0022 7A68     		ldr	r2, [r7, #4]
 640 0024 4A40     		eor	r2, r1
 641 0026 1A60     		str	r2, [r3]
 140:main.c        **** 	}
 642              		.loc 1 140 0 discriminator 1
 643 0028 F5E7     		b	.L41
 644              	.L43:
 645 002a C046     		.align	2
 646              	.L42:
 647 002c 74C0FF3F 		.word	1073725556
 648 0030 94C0FF3F 		.word	1073725588
 649              		.cfi_endproc
 650              	.LFE7:
 652              		.section	.text.labADC,"ax",%progbits
 653              		.align	2
 654              		.global	labADC
 655              		.code	16
 656              		.thumb_func
 658              	labADC:
 659              	.LFB8:
 141:main.c        **** }
 142:main.c        **** 
 143:main.c        **** void labADC(void)
 144:main.c        **** {
 660              		.loc 1 144 0
 661              		.cfi_startproc
 662 0000 80B5     		push	{r7, lr}
 663              	.LCFI21:
 664              		.cfi_def_cfa_offset 8
 665              		.cfi_offset 7, -8
 666              		.cfi_offset 14, -4
 667 0002 82B0     		sub	sp, sp, #8
 668              	.LCFI22:
 669              		.cfi_def_cfa_offset 16
 670 0004 00AF     		add	r7, sp, #0
 671              	.LCFI23:
 672              		.cfi_def_cfa_register 7
 145:main.c        **** 	// First select our ADC channel. I hope it is ADC1
 146:main.c        **** 	// Suppose I want to set the 3rd bit of register R, then
 147:main.c        **** 	// R |= (1 << 3)
 148:main.c        **** 	// For clearin,
 149:main.c        **** 	// R &= ~(1 << 3)
 150:main.c        **** 	int digital;
 151:main.c        **** 	PINSEL1 |= (0x01 << 16);		// Make the pin as ADC
 673              		.loc 1 151 0
 674 0006 204B     		ldr	r3, .L48
 675 0008 1F4A     		ldr	r2, .L48
 676 000a 1268     		ldr	r2, [r2]
 677 000c 8021     		mov	r1, #128
 678 000e 4902     		lsl	r1, r1, #9
 679 0010 0A43     		orr	r2, r1
 680 0012 1A60     		str	r2, [r3]
 152:main.c        **** 	PCONP	|= (0x01 << 12);		// Switch on the ADC	 
 681              		.loc 1 152 0
 682 0014 1D4B     		ldr	r3, .L48+4
 683 0016 1D4A     		ldr	r2, .L48+4
 684 0018 1268     		ldr	r2, [r2]
 685 001a 8021     		mov	r1, #128
 686 001c 4901     		lsl	r1, r1, #5
 687 001e 0A43     		orr	r2, r1
 688 0020 1A60     		str	r2, [r3]
 153:main.c        **** 
 154:main.c        **** 	AD0CR |= (0x01 << 1);		// ADC1
 689              		.loc 1 154 0
 690 0022 1B4B     		ldr	r3, .L48+8
 691 0024 1A4A     		ldr	r2, .L48+8
 692 0026 1268     		ldr	r2, [r2]
 693 0028 0221     		mov	r1, #2
 694 002a 0A43     		orr	r2, r1
 695 002c 1A60     		str	r2, [r3]
 155:main.c        **** 	AD0CR |= (0xFF << 8);		// Get the slowest ADC system clock. Too lazy to calculate.
 696              		.loc 1 155 0
 697 002e 184B     		ldr	r3, .L48+8
 698 0030 174A     		ldr	r2, .L48+8
 699 0032 1268     		ldr	r2, [r2]
 700 0034 FF21     		mov	r1, #255
 701 0036 0902     		lsl	r1, r1, #8
 702 0038 0A43     		orr	r2, r1
 703 003a 1A60     		str	r2, [r3]
 156:main.c        **** 	AD0CR |= (0x01 << 16);		// Burst on. This means that sampling takes regularly.
 704              		.loc 1 156 0
 705 003c 144B     		ldr	r3, .L48+8
 706 003e 144A     		ldr	r2, .L48+8
 707 0040 1268     		ldr	r2, [r2]
 708 0042 8021     		mov	r1, #128
 709 0044 4902     		lsl	r1, r1, #9
 710 0046 0A43     		orr	r2, r1
 711 0048 1A60     		str	r2, [r3]
 157:main.c        **** 	AD0CR |= (0x02 << 17);		// CLKS = 010, 9 clock cycles for each conversion, 8 bit resolution.
 712              		.loc 1 157 0
 713 004a 114B     		ldr	r3, .L48+8
 714 004c 104A     		ldr	r2, .L48+8
 715 004e 1268     		ldr	r2, [r2]
 716 0050 8021     		mov	r1, #128
 717 0052 C902     		lsl	r1, r1, #11
 718 0054 0A43     		orr	r2, r1
 719 0056 1A60     		str	r2, [r3]
 158:main.c        **** 	AD0CR |= (0x01 << 21); 		// ADC is operational
 720              		.loc 1 158 0
 721 0058 0D4B     		ldr	r3, .L48+8
 722 005a 0D4A     		ldr	r2, .L48+8
 723 005c 1268     		ldr	r2, [r2]
 724 005e 8021     		mov	r1, #128
 725 0060 8903     		lsl	r1, r1, #14
 726 0062 0A43     		orr	r2, r1
 727 0064 1A60     		str	r2, [r3]
 728 0066 00E0     		b	.L46
 729              	.L47:
 159:main.c        **** 
 160:main.c        **** 	// Our initialisation is done. Now go into an infinite loop
 161:main.c        **** 	while(1)
 162:main.c        **** 	{
 163:main.c        **** 		if(AD0DR1 & 0x80000000)
 164:main.c        **** 		{
 165:main.c        **** 			digital = ((AD0DR1 >> 8) & 0xFF);
 166:main.c        **** 			FIO3PIN = digital;
 167:main.c        **** 		}
 168:main.c        **** 	}
 730              		.loc 1 168 0
 731 0068 C046     		mov	r8, r8
 732              	.L46:
 163:main.c        **** 		if(AD0DR1 & 0x80000000)
 733              		.loc 1 163 0
 734 006a 0A4B     		ldr	r3, .L48+12
 735 006c 1B68     		ldr	r3, [r3]
 736 006e 002B     		cmp	r3, #0
 737 0070 FADA     		bge	.L47
 165:main.c        **** 			digital = ((AD0DR1 >> 8) & 0xFF);
 738              		.loc 1 165 0
 739 0072 084B     		ldr	r3, .L48+12
 740 0074 1B68     		ldr	r3, [r3]
 741 0076 1B0A     		lsr	r3, r3, #8
 742 0078 1A1C     		mov	r2, r3
 743 007a FF23     		mov	r3, #255
 744 007c 1340     		and	r3, r2
 745 007e 7B60     		str	r3, [r7, #4]
 166:main.c        **** 			FIO3PIN = digital;
 746              		.loc 1 166 0
 747 0080 054B     		ldr	r3, .L48+16
 748 0082 7A68     		ldr	r2, [r7, #4]
 749 0084 1A60     		str	r2, [r3]
 750              		.loc 1 168 0
 751 0086 EFE7     		b	.L47
 752              	.L49:
 753              		.align	2
 754              	.L48:
 755 0088 04C002E0 		.word	-536690684
 756 008c C4C01FE0 		.word	-534789948
 757 0090 004003E0 		.word	-536657920
 758 0094 144003E0 		.word	-536657900
 759 0098 74C0FF3F 		.word	1073725556
 760              		.cfi_endproc
 761              	.LFE8:
 763              		.global	__aeabi_fmul
 764              		.global	__aeabi_f2d
 765              		.global	__aeabi_ddiv
 766              		.global	__aeabi_d2iz
 767              		.section	.text.volt_out,"ax",%progbits
 768              		.align	2
 769              		.global	volt_out
 770              		.code	16
 771              		.thumb_func
 773              	volt_out:
 774              	.LFB9:
 169:main.c        **** }
 170:main.c        **** void volt_out(float voltage)
 171:main.c        **** {
 775              		.loc 1 171 0
 776              		.cfi_startproc
 777 0000 90B5     		push	{r4, r7, lr}
 778              	.LCFI24:
 779              		.cfi_def_cfa_offset 12
 780              		.cfi_offset 4, -12
 781              		.cfi_offset 7, -8
 782              		.cfi_offset 14, -4
 783 0002 85B0     		sub	sp, sp, #20
 784              	.LCFI25:
 785              		.cfi_def_cfa_offset 32
 786 0004 00AF     		add	r7, sp, #0
 787              	.LCFI26:
 788              		.cfi_def_cfa_register 7
 789 0006 7860     		str	r0, [r7, #4]
 172:main.c        **** 	PINSEL1 |= (0x02 << 20);		// AOUT is enabled
 790              		.loc 1 172 0
 791 0008 1B4B     		ldr	r3, .L52+8
 792 000a 1B4A     		ldr	r2, .L52+8
 793 000c 1268     		ldr	r2, [r2]
 794 000e 8021     		mov	r1, #128
 795 0010 8903     		lsl	r1, r1, #14
 796 0012 0A43     		orr	r2, r1
 797 0014 1A60     		str	r2, [r3]
 173:main.c        **** 	PCLKSEL0 |= (0x01 << 22);		// Select the appropriate clock configuration. Need to find out why
 798              		.loc 1 173 0
 799 0016 194B     		ldr	r3, .L52+12
 800 0018 184A     		ldr	r2, .L52+12
 801 001a 1268     		ldr	r2, [r2]
 802 001c 8021     		mov	r1, #128
 803 001e C903     		lsl	r1, r1, #15
 804 0020 0A43     		orr	r2, r1
 805 0022 1A60     		str	r2, [r3]
 174:main.c        **** 	PINMODE1 |= (0x03 << 20);		// Select the internal pullup.
 806              		.loc 1 174 0
 807 0024 164B     		ldr	r3, .L52+16
 808 0026 164A     		ldr	r2, .L52+16
 809 0028 1268     		ldr	r2, [r2]
 810 002a C021     		mov	r1, #192
 811 002c 8903     		lsl	r1, r1, #14
 812 002e 0A43     		orr	r2, r1
 813 0030 1A60     		str	r2, [r3]
 814              	.L51:
 175:main.c        **** 	int value;
 176:main.c        **** 	while(1)
 177:main.c        **** 	{
 178:main.c        **** 		value=voltage*1023/3.3;
 815              		.loc 1 178 0 discriminator 1
 816 0032 7868     		ldr	r0, [r7, #4]
 817 0034 1349     		ldr	r1, .L52+20
 818 0036 FFF7FEFF 		bl	__aeabi_fmul
 819 003a 031C     		add	r3, r0, #0
 820 003c 181C     		add	r0, r3, #0
 821 003e FFF7FEFF 		bl	__aeabi_f2d
 822 0042 031C     		mov	r3, r0
 823 0044 0C1C     		mov	r4, r1
 824 0046 181C     		mov	r0, r3
 825 0048 211C     		mov	r1, r4
 826 004a 0A4B     		ldr	r3, .L52+4
 827 004c 084A     		ldr	r2, .L52
 828 004e FFF7FEFF 		bl	__aeabi_ddiv
 829 0052 031C     		mov	r3, r0
 830 0054 0C1C     		mov	r4, r1
 831 0056 181C     		mov	r0, r3
 832 0058 211C     		mov	r1, r4
 833 005a FFF7FEFF 		bl	__aeabi_d2iz
 834 005e 031C     		mov	r3, r0
 835 0060 FB60     		str	r3, [r7, #12]
 179:main.c        **** 		DACR = (value << 6);
 836              		.loc 1 179 0 discriminator 1
 837 0062 094B     		ldr	r3, .L52+24
 838 0064 FA68     		ldr	r2, [r7, #12]
 839 0066 9201     		lsl	r2, r2, #6
 840 0068 1A60     		str	r2, [r3]
 180:main.c        **** 	}
 841              		.loc 1 180 0 discriminator 1
 842 006a E2E7     		b	.L51
 843              	.L53:
 844 006c C046C046 		.align	3
 845              	.L52:
 846 0070 66666666 		.word	1717986918
 847 0074 66660A40 		.word	1074423398
 848 0078 04C002E0 		.word	-536690684
 849 007c A8C11FE0 		.word	-534789720
 850 0080 44C002E0 		.word	-536690620
 851 0084 00C07F44 		.word	1149222912
 852 0088 00C006E0 		.word	-536428544
 853              		.cfi_endproc
 854              	.LFE9:
 856 008c C046C046 		.section	.text.sawtoothDAC,"ax",%progbits
 857              		.align	2
 858              		.global	sawtoothDAC
 859              		.code	16
 860              		.thumb_func
 862              	sawtoothDAC:
 863              	.LFB10:
 181:main.c        **** 	
 182:main.c        **** }
 183:main.c        **** void sawtoothDAC(void)
 184:main.c        **** {
 864              		.loc 1 184 0
 865              		.cfi_startproc
 866 0000 80B5     		push	{r7, lr}
 867              	.LCFI27:
 868              		.cfi_def_cfa_offset 8
 869              		.cfi_offset 7, -8
 870              		.cfi_offset 14, -4
 871 0002 82B0     		sub	sp, sp, #8
 872              	.LCFI28:
 873              		.cfi_def_cfa_offset 16
 874 0004 00AF     		add	r7, sp, #0
 875              	.LCFI29:
 876              		.cfi_def_cfa_register 7
 185:main.c        **** 	PINSEL1 |= (0x02 << 20);		// AOUT is enabled
 877              		.loc 1 185 0
 878 0006 134B     		ldr	r3, .L58
 879 0008 124A     		ldr	r2, .L58
 880 000a 1268     		ldr	r2, [r2]
 881 000c 8021     		mov	r1, #128
 882 000e 8903     		lsl	r1, r1, #14
 883 0010 0A43     		orr	r2, r1
 884 0012 1A60     		str	r2, [r3]
 186:main.c        **** 	PCLKSEL0 |= (0x01 << 22);		// Select the appropriate clock configuration. Need to find out why
 885              		.loc 1 186 0
 886 0014 104B     		ldr	r3, .L58+4
 887 0016 104A     		ldr	r2, .L58+4
 888 0018 1268     		ldr	r2, [r2]
 889 001a 8021     		mov	r1, #128
 890 001c C903     		lsl	r1, r1, #15
 891 001e 0A43     		orr	r2, r1
 892 0020 1A60     		str	r2, [r3]
 187:main.c        **** 	PINMODE1 |= (0x03 << 20);		// Select the internal pullup.
 893              		.loc 1 187 0
 894 0022 0E4B     		ldr	r3, .L58+8
 895 0024 0D4A     		ldr	r2, .L58+8
 896 0026 1268     		ldr	r2, [r2]
 897 0028 C021     		mov	r1, #192
 898 002a 8903     		lsl	r1, r1, #14
 899 002c 0A43     		orr	r2, r1
 900 002e 1A60     		str	r2, [r3]
 188:main.c        **** 	
 189:main.c        **** 	int value = 0;
 901              		.loc 1 189 0
 902 0030 0023     		mov	r3, #0
 903 0032 7B60     		str	r3, [r7, #4]
 190:main.c        **** 
 191:main.c        **** 	while(1)
 192:main.c        **** 	{
 193:main.c        **** 		while(value < 0x400)
 904              		.loc 1 193 0
 905 0034 06E0     		b	.L55
 906              	.L56:
 194:main.c        **** 		{
 195:main.c        **** 			DACR = (value << 6);
 907              		.loc 1 195 0
 908 0036 0A4B     		ldr	r3, .L58+12
 909 0038 7A68     		ldr	r2, [r7, #4]
 910 003a 9201     		lsl	r2, r2, #6
 911 003c 1A60     		str	r2, [r3]
 196:main.c        **** 			value += 1;
 912              		.loc 1 196 0
 913 003e 7B68     		ldr	r3, [r7, #4]
 914 0040 0133     		add	r3, r3, #1
 915 0042 7B60     		str	r3, [r7, #4]
 916              	.L55:
 193:main.c        **** 		while(value < 0x400)
 917              		.loc 1 193 0 discriminator 1
 918 0044 7A68     		ldr	r2, [r7, #4]
 919 0046 074B     		ldr	r3, .L58+16
 920 0048 9A42     		cmp	r2, r3
 921 004a F4DD     		ble	.L56
 197:main.c        **** 		}
 198:main.c        **** 		value = 0;
 922              		.loc 1 198 0
 923 004c 0023     		mov	r3, #0
 924 004e 7B60     		str	r3, [r7, #4]
 199:main.c        **** 	}
 925              		.loc 1 199 0
 926 0050 C046     		mov	r8, r8
 193:main.c        **** 		while(value < 0x400)
 927              		.loc 1 193 0
 928 0052 F7E7     		b	.L55
 929              	.L59:
 930              		.align	2
 931              	.L58:
 932 0054 04C002E0 		.word	-536690684
 933 0058 A8C11FE0 		.word	-534789720
 934 005c 44C002E0 		.word	-536690620
 935 0060 00C006E0 		.word	-536428544
 936 0064 FF030000 		.word	1023
 937              		.cfi_endproc
 938              	.LFE10:
 940              		.global	__aeabi_fadd
 941              		.global	__aeabi_fsub
 942              		.section	.rodata
 943              		.align	2
 944              	.LC0:
 945 0000 00000000 		.word	0
 946 0004 77BE1F3E 		.word	1042267767
 947 0008 9A99993E 		.word	1050253722
 948 000c 6666E63E 		.word	1055286886
 949 0010 E17A143F 		.word	1058306785
 950 0014 F4FD343F 		.word	1060437492
 951 0018 CDCC4C3F 		.word	1061997773
 952 001c 0AD7633F 		.word	1063507722
 953 0020 3333733F 		.word	1064514355
 954 0024 48E17A3F 		.word	1065017672
 955 0028 0000803F 		.word	1065353216
 956              		.section	.text.sinDAC,"ax",%progbits
 957              		.align	2
 958              		.global	sinDAC
 959              		.code	16
 960              		.thumb_func
 962              	sinDAC:
 963              	.LFB11:
 200:main.c        **** 	
 201:main.c        **** }
 202:main.c        **** 
 203:main.c        **** void sinDAC(void)
 204:main.c        **** {
 964              		.loc 1 204 0
 965              		.cfi_startproc
 966 0000 90B5     		push	{r4, r7, lr}
 967              	.LCFI30:
 968              		.cfi_def_cfa_offset 12
 969              		.cfi_offset 4, -12
 970              		.cfi_offset 7, -8
 971              		.cfi_offset 14, -4
 972 0002 8FB0     		sub	sp, sp, #60
 973              	.LCFI31:
 974              		.cfi_def_cfa_offset 72
 975 0004 00AF     		add	r7, sp, #0
 976              	.LCFI32:
 977              		.cfi_def_cfa_register 7
 205:main.c        **** 	PINSEL1 |= (0x02 << 20);		// AOUT is enabled
 978              		.loc 1 205 0
 979 0006 704B     		ldr	r3, .L70+8
 980 0008 6F4A     		ldr	r2, .L70+8
 981 000a 1268     		ldr	r2, [r2]
 982 000c 8021     		mov	r1, #128
 983 000e 8903     		lsl	r1, r1, #14
 984 0010 0A43     		orr	r2, r1
 985 0012 1A60     		str	r2, [r3]
 206:main.c        **** 	PCLKSEL0 |= (0x01 << 22);		// Select the appropriate clock configuration. Need to find out why
 986              		.loc 1 206 0
 987 0014 6D4B     		ldr	r3, .L70+12
 988 0016 6D4A     		ldr	r2, .L70+12
 989 0018 1268     		ldr	r2, [r2]
 990 001a 8021     		mov	r1, #128
 991 001c C903     		lsl	r1, r1, #15
 992 001e 0A43     		orr	r2, r1
 993 0020 1A60     		str	r2, [r3]
 207:main.c        **** 	PINMODE1 |= (0x03 << 20);		// Select the internal pullup.
 994              		.loc 1 207 0
 995 0022 6B4B     		ldr	r3, .L70+16
 996 0024 6A4A     		ldr	r2, .L70+16
 997 0026 1268     		ldr	r2, [r2]
 998 0028 C021     		mov	r1, #192
 999 002a 8903     		lsl	r1, r1, #14
 1000 002c 0A43     		orr	r2, r1
 1001 002e 1A60     		str	r2, [r3]
 208:main.c        **** 	
 209:main.c        **** 	int value = 0,i;
 1002              		.loc 1 209 0
 1003 0030 0023     		mov	r3, #0
 1004 0032 7B63     		str	r3, [r7, #52]
 210:main.c        **** 	float sinval[] = {0,0.156,0.3,0.45,0.58,0.707,0.8,0.89,0.95,0.98,1.0};
 1005              		.loc 1 210 0
 1006 0034 3B1D     		add	r3, r7, #4
 1007 0036 674A     		ldr	r2, .L70+20
 1008 0038 13CA     		ldmia	r2!, {r0, r1, r4}
 1009 003a 13C3     		stmia	r3!, {r0, r1, r4}
 1010 003c 13CA     		ldmia	r2!, {r0, r1, r4}
 1011 003e 13C3     		stmia	r3!, {r0, r1, r4}
 1012 0040 13CA     		ldmia	r2!, {r0, r1, r4}
 1013 0042 13C3     		stmia	r3!, {r0, r1, r4}
 1014 0044 03CA     		ldmia	r2!, {r0, r1}
 1015 0046 03C3     		stmia	r3!, {r0, r1}
 1016              	.L69:
 211:main.c        **** 	while(1)
 212:main.c        **** 	{
 213:main.c        **** 		for(i=0;i<11;i++)
 1017              		.loc 1 213 0
 1018 0048 0023     		mov	r3, #0
 1019 004a 3B63     		str	r3, [r7, #48]
 1020 004c 27E0     		b	.L61
 1021              	.L62:
 214:main.c        **** 		{
 215:main.c        **** 			value = 1024 * (1 + sinval[i])/3.3;
 1022              		.loc 1 215 0 discriminator 2
 1023 004e 3B1D     		add	r3, r7, #4
 1024 0050 3A6B     		ldr	r2, [r7, #48]
 1025 0052 9200     		lsl	r2, r2, #2
 1026 0054 D358     		ldr	r3, [r2, r3]
 1027 0056 181C     		add	r0, r3, #0
 1028 0058 5F49     		ldr	r1, .L70+24
 1029 005a FFF7FEFF 		bl	__aeabi_fadd
 1030 005e 031C     		add	r3, r0, #0
 1031 0060 181C     		add	r0, r3, #0
 1032 0062 5E49     		ldr	r1, .L70+28
 1033 0064 FFF7FEFF 		bl	__aeabi_fmul
 1034 0068 031C     		add	r3, r0, #0
 1035 006a 181C     		add	r0, r3, #0
 1036 006c FFF7FEFF 		bl	__aeabi_f2d
 1037 0070 031C     		mov	r3, r0
 1038 0072 0C1C     		mov	r4, r1
 1039 0074 181C     		mov	r0, r3
 1040 0076 211C     		mov	r1, r4
 1041 0078 524B     		ldr	r3, .L70+4
 1042 007a 514A     		ldr	r2, .L70
 1043 007c FFF7FEFF 		bl	__aeabi_ddiv
 1044 0080 031C     		mov	r3, r0
 1045 0082 0C1C     		mov	r4, r1
 1046 0084 181C     		mov	r0, r3
 1047 0086 211C     		mov	r1, r4
 1048 0088 FFF7FEFF 		bl	__aeabi_d2iz
 1049 008c 031C     		mov	r3, r0
 1050 008e 7B63     		str	r3, [r7, #52]
 216:main.c        **** 			DACR = value<<6;
 1051              		.loc 1 216 0 discriminator 2
 1052 0090 534B     		ldr	r3, .L70+32
 1053 0092 7A6B     		ldr	r2, [r7, #52]
 1054 0094 9201     		lsl	r2, r2, #6
 1055 0096 1A60     		str	r2, [r3]
 213:main.c        **** 		for(i=0;i<11;i++)
 1056              		.loc 1 213 0 discriminator 2
 1057 0098 3B6B     		ldr	r3, [r7, #48]
 1058 009a 0133     		add	r3, r3, #1
 1059 009c 3B63     		str	r3, [r7, #48]
 1060              	.L61:
 213:main.c        **** 		for(i=0;i<11;i++)
 1061              		.loc 1 213 0 is_stmt 0 discriminator 1
 1062 009e 3B6B     		ldr	r3, [r7, #48]
 1063 00a0 0A2B     		cmp	r3, #10
 1064 00a2 D4DD     		ble	.L62
 217:main.c        **** 		}
 218:main.c        **** 		for(i=10;i>=0;i--)
 1065              		.loc 1 218 0 is_stmt 1
 1066 00a4 0A23     		mov	r3, #10
 1067 00a6 3B63     		str	r3, [r7, #48]
 1068 00a8 27E0     		b	.L63
 1069              	.L64:
 219:main.c        **** 		{
 220:main.c        **** 			value = 1024 * (1 + sinval[i])/3.3;
 1070              		.loc 1 220 0 discriminator 2
 1071 00aa 3B1D     		add	r3, r7, #4
 1072 00ac 3A6B     		ldr	r2, [r7, #48]
 1073 00ae 9200     		lsl	r2, r2, #2
 1074 00b0 D358     		ldr	r3, [r2, r3]
 1075 00b2 181C     		add	r0, r3, #0
 1076 00b4 4849     		ldr	r1, .L70+24
 1077 00b6 FFF7FEFF 		bl	__aeabi_fadd
 1078 00ba 031C     		add	r3, r0, #0
 1079 00bc 181C     		add	r0, r3, #0
 1080 00be 4749     		ldr	r1, .L70+28
 1081 00c0 FFF7FEFF 		bl	__aeabi_fmul
 1082 00c4 031C     		add	r3, r0, #0
 1083 00c6 181C     		add	r0, r3, #0
 1084 00c8 FFF7FEFF 		bl	__aeabi_f2d
 1085 00cc 031C     		mov	r3, r0
 1086 00ce 0C1C     		mov	r4, r1
 1087 00d0 181C     		mov	r0, r3
 1088 00d2 211C     		mov	r1, r4
 1089 00d4 3B4B     		ldr	r3, .L70+4
 1090 00d6 3A4A     		ldr	r2, .L70
 1091 00d8 FFF7FEFF 		bl	__aeabi_ddiv
 1092 00dc 031C     		mov	r3, r0
 1093 00de 0C1C     		mov	r4, r1
 1094 00e0 181C     		mov	r0, r3
 1095 00e2 211C     		mov	r1, r4
 1096 00e4 FFF7FEFF 		bl	__aeabi_d2iz
 1097 00e8 031C     		mov	r3, r0
 1098 00ea 7B63     		str	r3, [r7, #52]
 221:main.c        **** 			DACR = value<<6;
 1099              		.loc 1 221 0 discriminator 2
 1100 00ec 3C4B     		ldr	r3, .L70+32
 1101 00ee 7A6B     		ldr	r2, [r7, #52]
 1102 00f0 9201     		lsl	r2, r2, #6
 1103 00f2 1A60     		str	r2, [r3]
 218:main.c        **** 		for(i=10;i>=0;i--)
 1104              		.loc 1 218 0 discriminator 2
 1105 00f4 3B6B     		ldr	r3, [r7, #48]
 1106 00f6 013B     		sub	r3, r3, #1
 1107 00f8 3B63     		str	r3, [r7, #48]
 1108              	.L63:
 218:main.c        **** 		for(i=10;i>=0;i--)
 1109              		.loc 1 218 0 is_stmt 0 discriminator 1
 1110 00fa 3B6B     		ldr	r3, [r7, #48]
 1111 00fc 002B     		cmp	r3, #0
 1112 00fe D4DA     		bge	.L64
 222:main.c        **** 		}for(i=0;i<11;i++)
 1113              		.loc 1 222 0 is_stmt 1
 1114 0100 0023     		mov	r3, #0
 1115 0102 3B63     		str	r3, [r7, #48]
 1116 0104 27E0     		b	.L65
 1117              	.L66:
 223:main.c        **** 		{
 224:main.c        **** 			value = 1024 * (1 - sinval[i])/3.3;
 1118              		.loc 1 224 0 discriminator 2
 1119 0106 3B1D     		add	r3, r7, #4
 1120 0108 3A6B     		ldr	r2, [r7, #48]
 1121 010a 9200     		lsl	r2, r2, #2
 1122 010c D358     		ldr	r3, [r2, r3]
 1123 010e 3248     		ldr	r0, .L70+24
 1124 0110 191C     		add	r1, r3, #0
 1125 0112 FFF7FEFF 		bl	__aeabi_fsub
 1126 0116 031C     		add	r3, r0, #0
 1127 0118 181C     		add	r0, r3, #0
 1128 011a 3049     		ldr	r1, .L70+28
 1129 011c FFF7FEFF 		bl	__aeabi_fmul
 1130 0120 031C     		add	r3, r0, #0
 1131 0122 181C     		add	r0, r3, #0
 1132 0124 FFF7FEFF 		bl	__aeabi_f2d
 1133 0128 031C     		mov	r3, r0
 1134 012a 0C1C     		mov	r4, r1
 1135 012c 181C     		mov	r0, r3
 1136 012e 211C     		mov	r1, r4
 1137 0130 244B     		ldr	r3, .L70+4
 1138 0132 234A     		ldr	r2, .L70
 1139 0134 FFF7FEFF 		bl	__aeabi_ddiv
 1140 0138 031C     		mov	r3, r0
 1141 013a 0C1C     		mov	r4, r1
 1142 013c 181C     		mov	r0, r3
 1143 013e 211C     		mov	r1, r4
 1144 0140 FFF7FEFF 		bl	__aeabi_d2iz
 1145 0144 031C     		mov	r3, r0
 1146 0146 7B63     		str	r3, [r7, #52]
 225:main.c        **** 			DACR = value<<6;
 1147              		.loc 1 225 0 discriminator 2
 1148 0148 254B     		ldr	r3, .L70+32
 1149 014a 7A6B     		ldr	r2, [r7, #52]
 1150 014c 9201     		lsl	r2, r2, #6
 1151 014e 1A60     		str	r2, [r3]
 222:main.c        **** 		}for(i=0;i<11;i++)
 1152              		.loc 1 222 0 discriminator 2
 1153 0150 3B6B     		ldr	r3, [r7, #48]
 1154 0152 0133     		add	r3, r3, #1
 1155 0154 3B63     		str	r3, [r7, #48]
 1156              	.L65:
 222:main.c        **** 		}for(i=0;i<11;i++)
 1157              		.loc 1 222 0 is_stmt 0 discriminator 1
 1158 0156 3B6B     		ldr	r3, [r7, #48]
 1159 0158 0A2B     		cmp	r3, #10
 1160 015a D4DD     		ble	.L66
 226:main.c        **** 		}
 227:main.c        **** 		for(i=10;i>=0;i--)
 1161              		.loc 1 227 0 is_stmt 1
 1162 015c 0A23     		mov	r3, #10
 1163 015e 3B63     		str	r3, [r7, #48]
 1164 0160 27E0     		b	.L67
 1165              	.L68:
 228:main.c        **** 		{
 229:main.c        **** 			value = 1024 * (1 - sinval[i])/3.3;
 1166              		.loc 1 229 0 discriminator 2
 1167 0162 3B1D     		add	r3, r7, #4
 1168 0164 3A6B     		ldr	r2, [r7, #48]
 1169 0166 9200     		lsl	r2, r2, #2
 1170 0168 D358     		ldr	r3, [r2, r3]
 1171 016a 1B48     		ldr	r0, .L70+24
 1172 016c 191C     		add	r1, r3, #0
 1173 016e FFF7FEFF 		bl	__aeabi_fsub
 1174 0172 031C     		add	r3, r0, #0
 1175 0174 181C     		add	r0, r3, #0
 1176 0176 1949     		ldr	r1, .L70+28
 1177 0178 FFF7FEFF 		bl	__aeabi_fmul
 1178 017c 031C     		add	r3, r0, #0
 1179 017e 181C     		add	r0, r3, #0
 1180 0180 FFF7FEFF 		bl	__aeabi_f2d
 1181 0184 031C     		mov	r3, r0
 1182 0186 0C1C     		mov	r4, r1
 1183 0188 181C     		mov	r0, r3
 1184 018a 211C     		mov	r1, r4
 1185 018c 0D4B     		ldr	r3, .L70+4
 1186 018e 0C4A     		ldr	r2, .L70
 1187 0190 FFF7FEFF 		bl	__aeabi_ddiv
 1188 0194 031C     		mov	r3, r0
 1189 0196 0C1C     		mov	r4, r1
 1190 0198 181C     		mov	r0, r3
 1191 019a 211C     		mov	r1, r4
 1192 019c FFF7FEFF 		bl	__aeabi_d2iz
 1193 01a0 031C     		mov	r3, r0
 1194 01a2 7B63     		str	r3, [r7, #52]
 230:main.c        **** 			DACR = value<<6;
 1195              		.loc 1 230 0 discriminator 2
 1196 01a4 0E4B     		ldr	r3, .L70+32
 1197 01a6 7A6B     		ldr	r2, [r7, #52]
 1198 01a8 9201     		lsl	r2, r2, #6
 1199 01aa 1A60     		str	r2, [r3]
 227:main.c        **** 		for(i=10;i>=0;i--)
 1200              		.loc 1 227 0 discriminator 2
 1201 01ac 3B6B     		ldr	r3, [r7, #48]
 1202 01ae 013B     		sub	r3, r3, #1
 1203 01b0 3B63     		str	r3, [r7, #48]
 1204              	.L67:
 227:main.c        **** 		for(i=10;i>=0;i--)
 1205              		.loc 1 227 0 is_stmt 0 discriminator 1
 1206 01b2 3B6B     		ldr	r3, [r7, #48]
 1207 01b4 002B     		cmp	r3, #0
 1208 01b6 D4DA     		bge	.L68
 231:main.c        **** 		}
 232:main.c        **** 		
 233:main.c        **** 	}
 1209              		.loc 1 233 0 is_stmt 1
 1210 01b8 46E7     		b	.L69
 1211              	.L71:
 1212 01ba C046C046 		.align	3
 1212      C046
 1213              	.L70:
 1214 01c0 66666666 		.word	1717986918
 1215 01c4 66660A40 		.word	1074423398
 1216 01c8 04C002E0 		.word	-536690684
 1217 01cc A8C11FE0 		.word	-534789720
 1218 01d0 44C002E0 		.word	-536690620
 1219 01d4 00000000 		.word	.LC0
 1220 01d8 0000803F 		.word	1065353216
 1221 01dc 00008044 		.word	1149239296
 1222 01e0 00C006E0 		.word	-536428544
 1223              		.cfi_endproc
 1224              	.LFE11:
 1226 01e4 C046C046 		.section	.text.triangleDAC,"ax",%progbits
 1227              		.align	2
 1228              		.global	triangleDAC
 1229              		.code	16
 1230              		.thumb_func
 1232              	triangleDAC:
 1233              	.LFB12:
 234:main.c        **** 	
 235:main.c        **** } 
 236:main.c        **** 
 237:main.c        **** void triangleDAC(void)
 238:main.c        **** {
 1234              		.loc 1 238 0
 1235              		.cfi_startproc
 1236 0000 80B5     		push	{r7, lr}
 1237              	.LCFI33:
 1238              		.cfi_def_cfa_offset 8
 1239              		.cfi_offset 7, -8
 1240              		.cfi_offset 14, -4
 1241 0002 82B0     		sub	sp, sp, #8
 1242              	.LCFI34:
 1243              		.cfi_def_cfa_offset 16
 1244 0004 00AF     		add	r7, sp, #0
 1245              	.LCFI35:
 1246              		.cfi_def_cfa_register 7
 239:main.c        **** 	PINSEL1 |= (0x02 << 20);		// AOUT is enabled
 1247              		.loc 1 239 0
 1248 0006 184B     		ldr	r3, .L79
 1249 0008 174A     		ldr	r2, .L79
 1250 000a 1268     		ldr	r2, [r2]
 1251 000c 8021     		mov	r1, #128
 1252 000e 8903     		lsl	r1, r1, #14
 1253 0010 0A43     		orr	r2, r1
 1254 0012 1A60     		str	r2, [r3]
 240:main.c        **** 	PCLKSEL0 |= (0x01 << 22);		// Select the appropriate clock configuration. Need to find out why
 1255              		.loc 1 240 0
 1256 0014 154B     		ldr	r3, .L79+4
 1257 0016 154A     		ldr	r2, .L79+4
 1258 0018 1268     		ldr	r2, [r2]
 1259 001a 8021     		mov	r1, #128
 1260 001c C903     		lsl	r1, r1, #15
 1261 001e 0A43     		orr	r2, r1
 1262 0020 1A60     		str	r2, [r3]
 241:main.c        **** 	PINMODE1 |= (0x03 << 20);		// Select the internal pullup.
 1263              		.loc 1 241 0
 1264 0022 134B     		ldr	r3, .L79+8
 1265 0024 124A     		ldr	r2, .L79+8
 1266 0026 1268     		ldr	r2, [r2]
 1267 0028 C021     		mov	r1, #192
 1268 002a 8903     		lsl	r1, r1, #14
 1269 002c 0A43     		orr	r2, r1
 1270 002e 1A60     		str	r2, [r3]
 242:main.c        **** 	
 243:main.c        **** 	int value = 0;
 1271              		.loc 1 243 0
 1272 0030 0023     		mov	r3, #0
 1273 0032 7B60     		str	r3, [r7, #4]
 244:main.c        **** 
 245:main.c        **** 	while(1)
 246:main.c        **** 	{
 247:main.c        **** 		while(value < 0x400)
 1274              		.loc 1 247 0
 1275 0034 07E0     		b	.L73
 1276              	.L78:
 1277 0036 06E0     		b	.L73
 1278              	.L74:
 248:main.c        **** 		{
 249:main.c        **** 			DACR = (value << 6);
 1279              		.loc 1 249 0
 1280 0038 0E4B     		ldr	r3, .L79+12
 1281 003a 7A68     		ldr	r2, [r7, #4]
 1282 003c 9201     		lsl	r2, r2, #6
 1283 003e 1A60     		str	r2, [r3]
 250:main.c        **** 			value += 1;
 1284              		.loc 1 250 0
 1285 0040 7B68     		ldr	r3, [r7, #4]
 1286 0042 0133     		add	r3, r3, #1
 1287 0044 7B60     		str	r3, [r7, #4]
 1288              	.L73:
 247:main.c        **** 		while(value < 0x400)
 1289              		.loc 1 247 0 discriminator 1
 1290 0046 7A68     		ldr	r2, [r7, #4]
 1291 0048 0B4B     		ldr	r3, .L79+16
 1292 004a 9A42     		cmp	r2, r3
 1293 004c F4DD     		ble	.L74
 251:main.c        **** 		}
 252:main.c        **** 		while(value > 0)
 1294              		.loc 1 252 0
 1295 004e 06E0     		b	.L75
 1296              	.L76:
 253:main.c        **** 		{
 254:main.c        **** 			value -= 1;
 1297              		.loc 1 254 0
 1298 0050 7B68     		ldr	r3, [r7, #4]
 1299 0052 013B     		sub	r3, r3, #1
 1300 0054 7B60     		str	r3, [r7, #4]
 255:main.c        **** 			DACR = (value << 6);
 1301              		.loc 1 255 0
 1302 0056 074B     		ldr	r3, .L79+12
 1303 0058 7A68     		ldr	r2, [r7, #4]
 1304 005a 9201     		lsl	r2, r2, #6
 1305 005c 1A60     		str	r2, [r3]
 1306              	.L75:
 252:main.c        **** 		while(value > 0)
 1307              		.loc 1 252 0 discriminator 1
 1308 005e 7B68     		ldr	r3, [r7, #4]
 1309 0060 002B     		cmp	r3, #0
 1310 0062 F5DC     		bgt	.L76
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 	}
 1311              		.loc 1 258 0
 1312 0064 E7E7     		b	.L78
 1313              	.L80:
 1314 0066 C046     		.align	2
 1315              	.L79:
 1316 0068 04C002E0 		.word	-536690684
 1317 006c A8C11FE0 		.word	-534789720
 1318 0070 44C002E0 		.word	-536690620
 1319 0074 00C006E0 		.word	-536428544
 1320 0078 FF030000 		.word	1023
 1321              		.cfi_endproc
 1322              	.LFE12:
 1324              		.section	.text.relay,"ax",%progbits
 1325              		.align	2
 1326              		.global	relay
 1327              		.code	16
 1328              		.thumb_func
 1330              	relay:
 1331              	.LFB13:
 259:main.c        **** 	
 260:main.c        **** }
 261:main.c        **** 
 262:main.c        **** void relay(void)
 263:main.c        **** {
 1332              		.loc 1 263 0
 1333              		.cfi_startproc
 1334 0000 80B5     		push	{r7, lr}
 1335              	.LCFI36:
 1336              		.cfi_def_cfa_offset 8
 1337              		.cfi_offset 7, -8
 1338              		.cfi_offset 14, -4
 1339 0002 84B0     		sub	sp, sp, #16
 1340              	.LCFI37:
 1341              		.cfi_def_cfa_offset 24
 1342 0004 00AF     		add	r7, sp, #0
 1343              	.LCFI38:
 1344              		.cfi_def_cfa_register 7
 1345              	.L82:
 264:main.c        **** 	int a,b,c;
 265:main.c        **** 	while(1)
 266:main.c        **** 	{
 267:main.c        **** 		a = FIO4PIN;
 1346              		.loc 1 267 0 discriminator 1
 1347 0006 124B     		ldr	r3, .L83
 1348 0008 1B68     		ldr	r3, [r3]
 1349 000a BB60     		str	r3, [r7, #8]
 268:main.c        **** 		a = b;
 1350              		.loc 1 268 0 discriminator 1
 1351 000c 7B68     		ldr	r3, [r7, #4]
 1352 000e BB60     		str	r3, [r7, #8]
 269:main.c        **** 		a &= 0x01;				// get the values of 1st two bits
 1353              		.loc 1 269 0 discriminator 1
 1354 0010 BA68     		ldr	r2, [r7, #8]
 1355 0012 0123     		mov	r3, #1
 1356 0014 1340     		and	r3, r2
 1357 0016 BB60     		str	r3, [r7, #8]
 270:main.c        **** 		c = a;
 1358              		.loc 1 270 0 discriminator 1
 1359 0018 BB68     		ldr	r3, [r7, #8]
 1360 001a FB60     		str	r3, [r7, #12]
 271:main.c        **** 		b &= 0x02;
 1361              		.loc 1 271 0 discriminator 1
 1362 001c 7A68     		ldr	r2, [r7, #4]
 1363 001e 0223     		mov	r3, #2
 1364 0020 1340     		and	r3, r2
 1365 0022 7B60     		str	r3, [r7, #4]
 272:main.c        **** 		c = a|b;
 1366              		.loc 1 272 0 discriminator 1
 1367 0024 BA68     		ldr	r2, [r7, #8]
 1368 0026 7B68     		ldr	r3, [r7, #4]
 1369 0028 1343     		orr	r3, r2
 1370 002a FB60     		str	r3, [r7, #12]
 273:main.c        **** 		b = b<<1;
 1371              		.loc 1 273 0 discriminator 1
 1372 002c 7B68     		ldr	r3, [r7, #4]
 1373 002e 5B00     		lsl	r3, r3, #1
 1374 0030 7B60     		str	r3, [r7, #4]
 274:main.c        **** 		a = a|b;
 1375              		.loc 1 274 0 discriminator 1
 1376 0032 BA68     		ldr	r2, [r7, #8]
 1377 0034 7B68     		ldr	r3, [r7, #4]
 1378 0036 1343     		orr	r3, r2
 1379 0038 BB60     		str	r3, [r7, #8]
 275:main.c        **** 		a=a<<24; 
 1380              		.loc 1 275 0 discriminator 1
 1381 003a BB68     		ldr	r3, [r7, #8]
 1382 003c 1B06     		lsl	r3, r3, #24
 1383 003e BB60     		str	r3, [r7, #8]
 276:main.c        **** 		a = a|c;
 1384              		.loc 1 276 0 discriminator 1
 1385 0040 BA68     		ldr	r2, [r7, #8]
 1386 0042 FB68     		ldr	r3, [r7, #12]
 1387 0044 1343     		orr	r3, r2
 1388 0046 BB60     		str	r3, [r7, #8]
 277:main.c        **** 		FIO3PIN=a;
 1389              		.loc 1 277 0 discriminator 1
 1390 0048 024B     		ldr	r3, .L83+4
 1391 004a BA68     		ldr	r2, [r7, #8]
 1392 004c 1A60     		str	r2, [r3]
 278:main.c        **** 		
 279:main.c        **** 	}
 1393              		.loc 1 279 0 discriminator 1
 1394 004e DAE7     		b	.L82
 1395              	.L84:
 1396              		.align	2
 1397              	.L83:
 1398 0050 94C0FF3F 		.word	1073725588
 1399 0054 74C0FF3F 		.word	1073725556
 1400              		.cfi_endproc
 1401              	.LFE13:
 1403              		.section	.text.relay1,"ax",%progbits
 1404              		.align	2
 1405              		.global	relay1
 1406              		.code	16
 1407              		.thumb_func
 1409              	relay1:
 1410              	.LFB14:
 280:main.c        **** 
 281:main.c        **** }
 282:main.c        **** void relay1(void)
 283:main.c        **** {
 1411              		.loc 1 283 0
 1412              		.cfi_startproc
 1413 0000 80B5     		push	{r7, lr}
 1414              	.LCFI39:
 1415              		.cfi_def_cfa_offset 8
 1416              		.cfi_offset 7, -8
 1417              		.cfi_offset 14, -4
 1418 0002 00AF     		add	r7, sp, #0
 1419              	.LCFI40:
 1420              		.cfi_def_cfa_register 7
 1421              	.L86:
 284:main.c        **** 	
 285:main.c        **** 	while(1)
 286:main.c        **** 	{
 287:main.c        **** 		FIO3PIN=0x1000000;
 1422              		.loc 1 287 0 discriminator 1
 1423 0004 0C4B     		ldr	r3, .L87
 1424 0006 8022     		mov	r2, #128
 1425 0008 5204     		lsl	r2, r2, #17
 1426 000a 1A60     		str	r2, [r3]
 288:main.c        **** 		delay();
 1427              		.loc 1 288 0 discriminator 1
 1428 000c FFF7FEFF 		bl	delay
 289:main.c        **** 		delay();
 1429              		.loc 1 289 0 discriminator 1
 1430 0010 FFF7FEFF 		bl	delay
 290:main.c        **** 		delay();
 1431              		.loc 1 290 0 discriminator 1
 1432 0014 FFF7FEFF 		bl	delay
 291:main.c        **** 		delay();
 1433              		.loc 1 291 0 discriminator 1
 1434 0018 FFF7FEFF 		bl	delay
 292:main.c        **** 		FIO3PIN=0x4000000;
 1435              		.loc 1 292 0 discriminator 1
 1436 001c 064B     		ldr	r3, .L87
 1437 001e 8022     		mov	r2, #128
 1438 0020 D204     		lsl	r2, r2, #19
 1439 0022 1A60     		str	r2, [r3]
 293:main.c        **** 		delay();
 1440              		.loc 1 293 0 discriminator 1
 1441 0024 FFF7FEFF 		bl	delay
 294:main.c        **** 		delay();
 1442              		.loc 1 294 0 discriminator 1
 1443 0028 FFF7FEFF 		bl	delay
 295:main.c        **** 		delay();
 1444              		.loc 1 295 0 discriminator 1
 1445 002c FFF7FEFF 		bl	delay
 296:main.c        **** 		delay(); 
 1446              		.loc 1 296 0 discriminator 1
 1447 0030 FFF7FEFF 		bl	delay
 297:main.c        **** 					
 298:main.c        **** 	}
 1448              		.loc 1 298 0 discriminator 1
 1449 0034 E6E7     		b	.L86
 1450              	.L88:
 1451 0036 C046     		.align	2
 1452              	.L87:
 1453 0038 74C0FF3F 		.word	1073725556
 1454              		.cfi_endproc
 1455              	.LFE14:
 1457              		.section	.text.main,"ax",%progbits
 1458              		.align	2
 1459              		.global	main
 1460              		.code	16
 1461              		.thumb_func
 1463              	main:
 1464              	.LFB15:
 299:main.c        **** 
 300:main.c        **** }		
 301:main.c        **** /************************* main routine ***********************************************************
 302:main.c        **** 
 303:main.c        **** int main ()
 304:main.c        **** {
 1465              		.loc 1 304 0
 1466              		.cfi_startproc
 1467 0000 80B5     		push	{r7, lr}
 1468              	.LCFI41:
 1469              		.cfi_def_cfa_offset 8
 1470              		.cfi_offset 7, -8
 1471              		.cfi_offset 14, -4
 1472 0002 00AF     		add	r7, sp, #0
 1473              	.LCFI42:
 1474              		.cfi_def_cfa_register 7
 305:main.c        **** 	FIO3DIR=0xFFFFFFFF;
 1475              		.loc 1 305 0
 1476 0004 164B     		ldr	r3, .L90
 1477 0006 0122     		mov	r2, #1
 1478 0008 5242     		neg	r2, r2
 1479 000a 1A60     		str	r2, [r3]
 306:main.c        **** 	FIO4DIR=0x00;	
 1480              		.loc 1 306 0
 1481 000c 154B     		ldr	r3, .L90+4
 1482 000e 0022     		mov	r2, #0
 1483 0010 1A60     		str	r2, [r3]
 307:main.c        **** 	init_timer(((72000000/100)-1));
 1484              		.loc 1 307 0
 1485 0012 154B     		ldr	r3, .L90+8
 1486 0014 181C     		mov	r0, r3
 1487 0016 FFF7FEFF 		bl	init_timer
 308:main.c        **** 	// Since we know most of the things apriori, we will not make a generic
 309:main.c        **** 	// sine wave generator, but a specific and blunt sine wave generator.
 310:main.c        **** 	// Further, since we are very greedy, we will make a 0.4sin(wt), which
 311:main.c        **** 	// will ensure that the values don't cross 255. Hence we can replace
 312:main.c        **** 	// ldr with mov, which takes only one cycle.
 313:main.c        **** 	
 314:main.c        **** 	/*
 315:main.c        **** 		Calculations:
 316:main.c        **** 		Each MOV instruction takes 1 cycle. Each STR instruction takes
 317:main.c        **** 		2 cycles. There are 32 transfers. Hence there are totally 96 cycles
 318:main.c        **** 		per a sine cycle and possible atmost 4 cycles for branching. Hence,
 319:main.c        **** 		the total time per a sine cycle = 100 * cycle time
 320:main.c        **** 	*/
 321:main.c        **** 	
 322:main.c        **** 	asm("LDR	R0, =0xE006C000		@ Address of the DACR\n\t"
 1488              		.loc 1 322 0
 1489              	#APP
 1490              	@ 322 "main.c" 1
 1491 001a 1448     		LDR	R0, =0xE006C000		@ Address of the DACR
 1492              		loop:
 1493 001c 7C21     			MOV	R1, #124
 1494 001e 0160     		STR	R1, [R0]
 1495 0020 BA21     		MOV	R1, #186
 1496 0022 0160     		STR	R1, [R0]
 1497 0024 E721     		MOV	R1, #231
 1498 0026 0160     		STR	R1, [R0]
 1499 0028 F821     		MOV	R1, #248
 1500 002a 0160     		STR	R1, [R0]
 1501 002c E721     		MOV	R1, #231
 1502 002e 0160     		STR	R1, [R0]
 1503 0030 BA21     		MOV	R1, #186
 1504 0032 0160     		STR	R1, [R0]
 1505 0034 7C21     		MOV	R1, #124
 1506 0036 0160     		STR	R1, [R0]
 1507 0038 7C21     		MOV	R1, #124
 1508 003a 0160     		STR	R1, [R0]
 1509 003c 3E21     		MOV	R1, #62
 1510 003e 0160     		 STR	R1, [R0]
 1511 0040 1021     		MOV	R1, #16
 1512 0042 0160     		 STR	R1, [R0]
 1513 0044 0021     		MOV	R1, #0
 1514 0046 0160     		  STR	R1, [R0]
 1515 0048 1021     		MOV	R1, #16
 1516 004a 0160     		 STR	R1, [R0]
 1517 004c 3E21     		MOV	R1, #62
 1518 004e 0160     		 STR	R1, [R0]
 1519 0050 E4E7     			B loop
 1520              	@ 0 "" 2
 323:main.c        **** 		"loop:\n\t	"
 324:main.c        **** 		"MOV	R1, #124\n\t"
 325:main.c        **** 		"STR	R1, [R0]\n\t"
 326:main.c        **** 		"MOV	R1, #186\n\t"
 327:main.c        **** 		"STR	R1, [R0]\n\t"
 328:main.c        **** 		"MOV	R1, #231\n\t"
 329:main.c        **** 		"STR	R1, [R0]\n\t"
 330:main.c        **** 		"MOV	R1, #248\n\t"
 331:main.c        **** 		"STR	R1, [R0]\n\t"
 332:main.c        **** 		"MOV	R1, #231\n\t"
 333:main.c        **** 		"STR	R1, [R0]\n\t"
 334:main.c        **** 		"MOV	R1, #186\n\t"
 335:main.c        **** 		"STR	R1, [R0]\n\t"
 336:main.c        **** 		"MOV	R1, #124\n\t"
 337:main.c        **** 		"STR	R1, [R0]\n\t"
 338:main.c        **** 		"MOV	R1, #124\n\t"
 339:main.c        **** 		"STR	R1, [R0]\n\t"
 340:main.c        **** 		"MOV	R1, #62\n\t "
 341:main.c        **** 		"STR	R1, [R0]\n\t"
 342:main.c        **** 		"MOV	R1, #16\n\t "
 343:main.c        **** 		"STR	R1, [R0]\n\t"
 344:main.c        **** 		"MOV	R1, #0\n\t  "
 345:main.c        **** 		"STR	R1, [R0]\n\t"
 346:main.c        **** 		"MOV	R1, #16\n\t "
 347:main.c        **** 		"STR	R1, [R0]\n\t"
 348:main.c        **** 		"MOV	R1, #62\n\t "
 349:main.c        **** 		"STR	R1, [R0]\n\t"
 350:main.c        **** 		"	B loop"
 351:main.c        **** 		
 352:main.c        **** 	);
 353:main.c        **** 	return 0;
 1521              		.loc 1 353 0
 1522              		.code	16
 1523 0052 0023     		mov	r3, #0
 354:main.c        **** }
 1524              		.loc 1 354 0
 1525 0054 181C     		mov	r0, r3
 1526 0056 BD46     		mov	sp, r7
 1527              		@ sp needed for prologue
 1528 0058 80BC     		pop	{r7}
 1529 005a 02BC     		pop	{r1}
 1530 005c 0847     		bx	r1
 1531              	.L91:
 1532 005e C046     		.align	2
 1533              	.L90:
 1534 0060 60C0FF3F 		.word	1073725536
 1535 0064 80C0FF3F 		.word	1073725568
 1536 0068 7FFC0A00 		.word	719999
 1537              		.cfi_endproc
 1538              	.LFE15:
 1540              		.text
 1541              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccNoiOtV.s:19     .text.TargetResetInit:0000000000000000 $t
     /tmp/ccNoiOtV.s:24     .text.TargetResetInit:0000000000000000 TargetResetInit
     /tmp/ccNoiOtV.s:197    .text.TargetResetInit:00000000000000f4 $d
     /tmp/ccNoiOtV.s:215    .text.delay:0000000000000000 $t
     /tmp/ccNoiOtV.s:219    .text.delay:0000000000000000 delay
     /tmp/ccNoiOtV.s:273    .text.delay:0000000000000038 $d
     /tmp/ccNoiOtV.s:278    .text.rotate:0000000000000000 $t
     /tmp/ccNoiOtV.s:283    .text.rotate:0000000000000000 rotate
     /tmp/ccNoiOtV.s:344    .text.rotate:0000000000000044 $d
     /tmp/ccNoiOtV.s:350    .text.rotate1:0000000000000000 $t
     /tmp/ccNoiOtV.s:355    .text.rotate1:0000000000000000 rotate1
     /tmp/ccNoiOtV.s:427    .text.rotate1:0000000000000058 $d
     /tmp/ccNoiOtV.s:433    .text.four_bit_add:0000000000000000 $t
     /tmp/ccNoiOtV.s:438    .text.four_bit_add:0000000000000000 four_bit_add
     /tmp/ccNoiOtV.s:507    .text.four_bit_add:0000000000000050 $d
     /tmp/ccNoiOtV.s:515    .text.reflect:0000000000000000 $t
     /tmp/ccNoiOtV.s:520    .text.reflect:0000000000000000 reflect
     /tmp/ccNoiOtV.s:551    .text.reflect:000000000000001c $d
     /tmp/ccNoiOtV.s:559    .text.blink:0000000000000000 $t
     /tmp/ccNoiOtV.s:564    .text.blink:0000000000000000 blink
     /tmp/ccNoiOtV.s:594    .text.blink:000000000000001c $d
     /tmp/ccNoiOtV.s:599    .text.bin2gry:0000000000000000 $t
     /tmp/ccNoiOtV.s:604    .text.bin2gry:0000000000000000 bin2gry
     /tmp/ccNoiOtV.s:647    .text.bin2gry:000000000000002c $d
     /tmp/ccNoiOtV.s:653    .text.labADC:0000000000000000 $t
     /tmp/ccNoiOtV.s:658    .text.labADC:0000000000000000 labADC
     /tmp/ccNoiOtV.s:755    .text.labADC:0000000000000088 $d
     /tmp/ccNoiOtV.s:768    .text.volt_out:0000000000000000 $t
     /tmp/ccNoiOtV.s:773    .text.volt_out:0000000000000000 volt_out
     /tmp/ccNoiOtV.s:846    .text.volt_out:0000000000000070 $d
     /tmp/ccNoiOtV.s:857    .text.sawtoothDAC:0000000000000000 $t
     /tmp/ccNoiOtV.s:862    .text.sawtoothDAC:0000000000000000 sawtoothDAC
     /tmp/ccNoiOtV.s:932    .text.sawtoothDAC:0000000000000054 $d
     /tmp/ccNoiOtV.s:943    .rodata:0000000000000000 $d
     /tmp/ccNoiOtV.s:957    .text.sinDAC:0000000000000000 $t
     /tmp/ccNoiOtV.s:962    .text.sinDAC:0000000000000000 sinDAC
     /tmp/ccNoiOtV.s:1214   .text.sinDAC:00000000000001c0 $d
     /tmp/ccNoiOtV.s:1227   .text.triangleDAC:0000000000000000 $t
     /tmp/ccNoiOtV.s:1232   .text.triangleDAC:0000000000000000 triangleDAC
     /tmp/ccNoiOtV.s:1316   .text.triangleDAC:0000000000000068 $d
     /tmp/ccNoiOtV.s:1325   .text.relay:0000000000000000 $t
     /tmp/ccNoiOtV.s:1330   .text.relay:0000000000000000 relay
     /tmp/ccNoiOtV.s:1398   .text.relay:0000000000000050 $d
     /tmp/ccNoiOtV.s:1404   .text.relay1:0000000000000000 $t
     /tmp/ccNoiOtV.s:1409   .text.relay1:0000000000000000 relay1
     /tmp/ccNoiOtV.s:1453   .text.relay1:0000000000000038 $d
     /tmp/ccNoiOtV.s:1458   .text.main:0000000000000000 $t
     /tmp/ccNoiOtV.s:1463   .text.main:0000000000000000 main
     /tmp/ccNoiOtV.s:1492   .text.main:000000000000001c loop
     /tmp/ccNoiOtV.s:1534   .text.main:0000000000000060 $d
                     .debug_frame:0000000000000010 $d
     /tmp/ccNoiOtV.s:856    .text.volt_out:000000000000008c $t
     /tmp/ccNoiOtV.s:1226   .text.sinDAC:00000000000001e4 $t

UNDEFINED SYMBOLS
__aeabi_fmul
__aeabi_f2d
__aeabi_ddiv
__aeabi_d2iz
__aeabi_fadd
__aeabi_fsub
init_timer
