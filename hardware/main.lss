
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .note.gnu.build-id 00000024  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00000460  00000024  00000024  00008024  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .interp       00000013  00000484  00000484  00008484  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .dynsym       00000000  00000498  00000498  00008498  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynstr       0000000b  00000498  00000498  00008498  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .gnu.hash     00000018  000004a4  000004a4  000084a4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .dynamic      00000068  40000000  40000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .got.plt      0000000c  40000068  40000068  00010068  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000004  40000074  40000074  00010074  2**2
                  ALLOC
  9 .stack        00000400  40000100  40000100  00010078  2**3
                  CONTENTS
 10 .comment      0000002a  00000000  00000000  00010478  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  000104a2  2**0
                  CONTENTS, READONLY
 12 .debug_aranges 00000120  00000000  00000000  000104d8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00000548  00000000  00000000  000105f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000001f1  00000000  00000000  00010b40  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000004ab  00000000  00000000  00010d31  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  000002d0  00000000  00000000  000111dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000001ca  00000000  00000000  000114ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    0000048a  00000000  00000000  00011676  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 000000c0  00000000  00000000  00011b00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000024 <Vectors>:
@ Exception Vectors
@  Mapped to Address 0.
@  Absolute addressing mode must be used.
@  Dummy Handlers are implemented as infinite loops which can be modified.

Vectors:        LDR     PC, Reset_Addr         
  24:	e59ff018 	ldr	pc, [pc, #24]	; 44 <Reset_Addr>
                LDR     PC, Undef_Addr
  28:	e59ff018 	ldr	pc, [pc, #24]	; 48 <Undef_Addr>
                LDR     PC, SWI_Addr
  2c:	e59ff018 	ldr	pc, [pc, #24]	; 4c <SWI_Addr>
                LDR     PC, PAbt_Addr
  30:	e59ff018 	ldr	pc, [pc, #24]	; 50 <PAbt_Addr>
                LDR     PC, DAbt_Addr
  34:	e59ff018 	ldr	pc, [pc, #24]	; 54 <DAbt_Addr>
                NOP                            @ Reserved Vector 
  38:	e1a00000 	nop			; (mov r0, r0)
                LDR     PC, IRQ_Addr
  3c:	e59ff018 	ldr	pc, [pc, #24]	; 5c <IRQ_Addr>
@@                LDR     PC, [PC, #-0x0120]     @ Vector from VicVectAddr
                LDR     PC, FIQ_Addr
  40:	e59ff018 	ldr	pc, [pc, #24]	; 60 <FIQ_Addr>

00000044 <Reset_Addr>:
  44:	00000078 	.word	0x00000078

00000048 <Undef_Addr>:
  48:	00000064 	.word	0x00000064

0000004c <SWI_Addr>:
  4c:	00000068 	.word	0x00000068

00000050 <PAbt_Addr>:
  50:	0000006c 	.word	0x0000006c

00000054 <DAbt_Addr>:
  54:	00000070 	.word	0x00000070
  58:	b9206e28 	.word	0xb9206e28

0000005c <IRQ_Addr>:
  5c:	00000120 	.word	0x00000120

00000060 <FIQ_Addr>:
  60:	00000074 	.word	0x00000074

00000064 <Undef_Handler>:
DAbt_Addr:       .word     DAbt_Handler
                 .word     0xB9206E28             @ Reserved Address 
IRQ_Addr:        .word     IRQ_Handler
FIQ_Addr:        .word     FIQ_Handler

Undef_Handler:   B       Undef_Handler
  64:	eafffffe 	b	64 <Undef_Handler>

00000068 <SWI_Handler>:
@@ SWI_Handler:     B       SWI_Handler
.extern SoftwareInterrupt
SWI_Handler:     B       SoftwareInterrupt  @ see swi_handler.S
  68:	ea000046 	b	188 <SoftwareInterrupt>

0000006c <PAbt_Handler>:
PAbt_Handler:    B       PAbt_Handler
  6c:	eafffffe 	b	6c <PAbt_Handler>

00000070 <DAbt_Handler>:
DAbt_Handler:    B       DAbt_Handler
  70:	eafffffe 	b	70 <DAbt_Handler>

00000074 <FIQ_Handler>:
@@ handled thru assembler wrapper (see below)
@@ IRQ_Handler:    B       IRQ_Handler
FIQ_Handler:     B       FIQ_Handler
  74:	eafffffe 	b	74 <FIQ_Handler>

00000078 <Reset_Handler>:
@  Call low-level init C-function
@                IMPORT TargetResetInit
@                BL   TargetResetInit

                 .extern TargetResetInit
                 ldr     SP, =Stack_Top    @ temporary stack at Stack_Top
  78:	e59fd0e4 	ldr	sp, [pc, #228]	; 164 <IRQ_Handler+0x44>
                 LDR R0, =TargetResetInit
  7c:	e59f00e4 	ldr	r0, [pc, #228]	; 168 <IRQ_Handler+0x48>
                 MOV LR, PC
  80:	e1a0e00f 	mov	lr, pc
                 BX R0
  84:	e12fff10 	bx	r0


@  Setup Stack for each mode
                LDR     R0, =Stack_Top
  88:	e59f00d4 	ldr	r0, [pc, #212]	; 164 <IRQ_Handler+0x44>

@  Enter Undefined Instruction Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_UND | I_Bit | F_Bit
  8c:	e321f0db 	msr	CPSR_c, #219	; 0xdb
                MOV     SP, R0
  90:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #UND_Stack_Size
  94:	e2400000 	sub	r0, r0, #0

@  Enter Abort Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_ABT | I_Bit | F_Bit
  98:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
                MOV     SP, R0
  9c:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #ABT_Stack_Size
  a0:	e2400000 	sub	r0, r0, #0

@  Enter FIQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_FIQ | I_Bit | F_Bit
  a4:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                MOV     SP, R0
  a8:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #FIQ_Stack_Size
  ac:	e2400000 	sub	r0, r0, #0

@  Enter IRQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_IRQ | I_Bit | F_Bit
  b0:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
                MOV     SP, R0
  b4:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #IRQ_Stack_Size
  b8:	e2400c01 	sub	r0, r0, #256	; 0x100

@  Enter Supervisor Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SVC | I_Bit | F_Bit
  bc:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
                MOV     SP, R0
  c0:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #SVC_Stack_Size
  c4:	e2400c01 	sub	r0, r0, #256	; 0x100

@  Enter User Mode and set its Stack Pointer
@  mt:          MSR     CPSR_c, #Mode_USR
                MSR     CPSR_c, #Mode_USR | I_Bit
  c8:	e321f090 	msr	CPSR_c, #144	; 0x90
                MOV     SP, R0
  cc:	e1a0d000 	mov	sp, r0
                SUB     SL, SP, #USR_Stack_Size
  d0:	e24dac02 	sub	sl, sp, #512	; 0x200
@  mt: Start application in USR-mode with IRQ-exceptions disabled.
@  They can be enabled at runtime thru IntEnable in swi.h/swi_handler.S.

@  Relocate .data section (Copy from ROM to RAM)
                LDR     R1, =_etext 
  d4:	e59f1090 	ldr	r1, [pc, #144]	; 16c <IRQ_Handler+0x4c>
                LDR     R2, =_data 
  d8:	e59f2090 	ldr	r2, [pc, #144]	; 170 <IRQ_Handler+0x50>
                LDR     R3, =_edata 
  dc:	e59f3090 	ldr	r3, [pc, #144]	; 174 <IRQ_Handler+0x54>
                CMP     R2, R3
  e0:	e1520003 	cmp	r2, r3
                BEQ     DataIsEmpty
  e4:	0a000003 	beq	f8 <DataIsEmpty>

000000e8 <LoopRel>:
LoopRel:        CMP     R2, R3 
  e8:	e1520003 	cmp	r2, r3
                LDRLO   R0, [R1], #4 
  ec:	34910004 	ldrcc	r0, [r1], #4
                STRLO   R0, [R2], #4 
  f0:	34820004 	strcc	r0, [r2], #4
                BLO     LoopRel 
  f4:	3afffffb 	bcc	e8 <LoopRel>

000000f8 <DataIsEmpty>:
DataIsEmpty:
 
@  Clear .bss section (Zero init)
                MOV     R0, #0 
  f8:	e3a00000 	mov	r0, #0
                LDR     R1, =__bss_start__ 
  fc:	e59f1074 	ldr	r1, [pc, #116]	; 178 <IRQ_Handler+0x58>
                LDR     R2, =__bss_end__ 
 100:	e59f2074 	ldr	r2, [pc, #116]	; 17c <IRQ_Handler+0x5c>
                CMP     R1,R2
 104:	e1510002 	cmp	r1, r2
                BEQ     BSSIsEmpty
 108:	0a000002 	beq	118 <BSSIsEmpty>

0000010c <LoopZI>:
LoopZI:         CMP     R1, R2 
 10c:	e1510002 	cmp	r1, r2
                STRLO   R0, [R1], #4 
 110:	34810004 	strcc	r0, [r1], #4
                BLO     LoopZI 
 114:	3afffffc 	bcc	10c <LoopZI>

00000118 <BSSIsEmpty>:

@  Enter the C code
@                IMPORT  __main
@                LDR     R0, =__main
                .extern main
                LDR R0, =main
 118:	e59f0060 	ldr	r0, [pc, #96]	; 180 <IRQ_Handler+0x60>
                BX      R0
 11c:	e12fff10 	bx	r0

00000120 <IRQ_Handler>:
.arm
IRQ_Handler:

@- Manage Exception Entry
@- Adjust and save LR_irq in IRQ stack
            sub         lr, lr, #4
 120:	e24ee004 	sub	lr, lr, #4
            stmfd       sp!, {lr}
 124:	e92d4000 	push	{lr}

@- Save SPSR need to be saved for nested interrupt
            mrs         r14, SPSR
 128:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
 12c:	e92d4000 	push	{lr}

@- Save and r0 in IRQ stack
            stmfd       sp!, {r0}
 130:	e92d0001 	push	{r0}

@- Load the ISR-Address from VICVectAddr
            ldr         r14, =LPC_BASE_VIC
 134:	e59fe048 	ldr	lr, [pc, #72]	; 184 <IRQ_Handler+0x64>
            ldr         r0 , [r14, #VIC_VectAddr]
 138:	e59e0f00 	ldr	r0, [lr, #3840]	; 0xf00

@- Enable Interrupt and Switch in Supervisor Mode
           msr         CPSR_c, #Mode_SVC
 13c:	e321f013 	msr	CPSR_c, #19

@- Save scratch/used registers and LR in User Stack
            stmfd       sp!, { r1-r3, r12, r14 }
 140:	e92d500e 	push	{r1, r2, r3, ip, lr}

@- Branch to the routine pointed by the VIC_VectAddr
            mov         r14, pc
 144:	e1a0e00f 	mov	lr, pc
            bx          r0
 148:	e12fff10 	bx	r0

@- Restore scratch/used registers and LR from User Stack
            ldmia       sp!, { r1-r3, r12, r14 }
 14c:	e8bd500e 	pop	{r1, r2, r3, ip, lr}

@- Disable Interrupt and switch back in IRQ mode
            msr         CPSR_c, #I_Bit | Mode_IRQ
 150:	e321f092 	msr	CPSR_c, #146	; 0x92
@   here since already done in the ISRs
@@           ldr         r14, =LPC_BASE_VIC
@@           str         r14, [r14, #VIC_VectAddr]

@- Restore R0
            ldmia       sp!, {r0}
 154:	e8bd0001 	pop	{r0}

@- Restore SPSR_irq and r0 from IRQ stack
            ldmia       sp!, {r14}
 158:	e8bd4000 	pop	{lr}
            msr         SPSR_cxsf, r14
 15c:	e16ff00e 	msr	SPSR_fsxc, lr

@- Restore adjusted  LR_irq from IRQ stack directly in the PC
            ldmia       sp!, {pc}^
 160:	e8fd8000 	ldm	sp!, {pc}^
@  Call low-level init C-function
@                IMPORT TargetResetInit
@                BL   TargetResetInit

                 .extern TargetResetInit
                 ldr     SP, =Stack_Top    @ temporary stack at Stack_Top
 164:	40000500 	.word	0x40000500
                 LDR R0, =TargetResetInit
 168:	000001fd 	.word	0x000001fd
                SUB     SL, SP, #USR_Stack_Size
@  mt: Start application in USR-mode with IRQ-exceptions disabled.
@  They can be enabled at runtime thru IntEnable in swi.h/swi_handler.S.

@  Relocate .data section (Copy from ROM to RAM)
                LDR     R1, =_etext 
 16c:	000004bc 	.word	0x000004bc
                LDR     R2, =_data 
 170:	40000000 	.word	0x40000000
                LDR     R3, =_edata 
 174:	40000074 	.word	0x40000074
                BLO     LoopRel 
DataIsEmpty:
 
@  Clear .bss section (Zero init)
                MOV     R0, #0 
                LDR     R1, =__bss_start__ 
 178:	40000074 	.word	0x40000074
                LDR     R2, =__bss_end__ 
 17c:	40000078 	.word	0x40000078

@  Enter the C code
@                IMPORT  __main
@                LDR     R0, =__main
                .extern main
                LDR R0, =main
 180:	00000329 	.word	0x00000329

@- Save and r0 in IRQ stack
            stmfd       sp!, {r0}

@- Load the ISR-Address from VICVectAddr
            ldr         r14, =LPC_BASE_VIC
 184:	fffff000 	.word	0xfffff000

00000188 <SoftwareInterrupt>:
@*  mthomas: Expects that SWI instruction is called from ARM-mode   *
@*           (not thumb). This is the case if the functions below  *
@*           (IntEnable/IntDisable) get used.
@********************************************************************
SoftwareInterrupt:
	LDR		R0, [LR, #-4]          /* get swi instruction code (ARM-mode) */
 188:	e51e0004 	ldr	r0, [lr, #-4]
	BIC		R0, R0, #0xff000000    /* clear top 8 bits leaving swi "comment field"=number */
 18c:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
	CMP		R0, #4                 /* range check */
 190:	e3500004 	cmp	r0, #4
	LDRLO	PC, [PC, R0, LSL #2]   /* get jump-address from table */
 194:	379ff100 	ldrcc	pc, [pc, r0, lsl #2]
	MOVS	PC, LR                 /* if out of range: do nothing and return */
 198:	e1b0f00e 	movs	pc, lr

0000019c <SwiFunction>:
 19c:	000001ac 	.word	0x000001ac
 1a0:	000001bc 	.word	0x000001bc
 1a4:	000001cc 	.word	0x000001cc
 1a8:	000001dc 	.word	0x000001dc

000001ac <IRQDisable>:
.word IRQEnable
.word FIQDisable
.word FIQEnable

IRQDisable:
	MRS		R0, SPSR
 1ac:	e14f0000 	mrs	r0, SPSR
	ORR		R0, R0, #I_Bit
 1b0:	e3800080 	orr	r0, r0, #128	; 0x80
	MSR		SPSR_c, R0
 1b4:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1b8:	e1b0f00e 	movs	pc, lr

000001bc <IRQEnable>:

IRQEnable:
	MRS		R0, SPSR
 1bc:	e14f0000 	mrs	r0, SPSR
	BIC		R0, R0, #I_Bit
 1c0:	e3c00080 	bic	r0, r0, #128	; 0x80
	MSR		SPSR_c, R0
 1c4:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1c8:	e1b0f00e 	movs	pc, lr

000001cc <FIQDisable>:

FIQDisable:
	MRS		R0, SPSR
 1cc:	e14f0000 	mrs	r0, SPSR
	ORR		R0, R0, #F_Bit
 1d0:	e3800040 	orr	r0, r0, #64	; 0x40
	MSR		SPSR_c, R0
 1d4:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1d8:	e1b0f00e 	movs	pc, lr

000001dc <FIQEnable>:

FIQEnable:
	MRS		R0, SPSR
 1dc:	e14f0000 	mrs	r0, SPSR
	BIC		R0, R0, #F_Bit
 1e0:	e3c00040 	bic	r0, r0, #64	; 0x40
	MSR		SPSR_c, R0
 1e4:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1e8:	e1b0f00e 	movs	pc, lr

000001ec <IntEnable>:
@*  Parameters:      None                                             *
@*  input  :         None                                             * 
@*  output :         None                                             *
@**********************************************************************
IntEnable:
	SWI     SWI_IRQ_EN
 1ec:	ef000001 	svc	0x00000001
	BX      lr
 1f0:	e12fff1e 	bx	lr

000001f4 <IntDisable>:
@*  Parameters     : None                                             *
@*  input          : None                                             * 
@*  output         : None                                             *
@**********************************************************************
IntDisable:
	SWI     SWI_IRQ_DIS
 1f4:	ef000000 	svc	0x00000000
	BX      lr
 1f8:	e12fff1e 	bx	lr

000001fc <TargetResetInit>:

/**********************************************************************************************************
			Routine to set processor and peripheral clock 
***********************************************************************************************************/
void  TargetResetInit(void)
{
 1fc:	b580      	push	{r7, lr}
 1fe:	af00      	add	r7, sp, #0
  // 72 Mhz Frequency
  if ((PLLSTAT & 0x02000000) > 0)
 200:	4b3b      	ldr	r3, [pc, #236]	; (2f0 <USR_Stack_Size+0xf0>)
 202:	681a      	ldr	r2, [r3, #0]
 204:	2380      	movs	r3, #128	; 0x80
 206:	049b      	lsls	r3, r3, #18
 208:	4013      	ands	r3, r2
 20a:	d00b      	beq.n	224 <USR_Stack_Size+0x24>
  {
      /* If the PLL is already running   */
      PLLCON  &= ~0x02;                         /* Disconnect the PLL                                       */
 20c:	4b39      	ldr	r3, [pc, #228]	; (2f4 <USR_Stack_Size+0xf4>)
 20e:	4a39      	ldr	r2, [pc, #228]	; (2f4 <USR_Stack_Size+0xf4>)
 210:	6812      	ldr	r2, [r2, #0]
 212:	2102      	movs	r1, #2
 214:	438a      	bics	r2, r1
 216:	601a      	str	r2, [r3, #0]
      PLLFEED  =  0xAA;                        	/* PLL register update sequence, 0xAA, 0x55                 */
 218:	4b37      	ldr	r3, [pc, #220]	; (2f8 <USR_Stack_Size+0xf8>)
 21a:	22aa      	movs	r2, #170	; 0xaa
 21c:	601a      	str	r2, [r3, #0]
      PLLFEED  =  0x55;
 21e:	4b36      	ldr	r3, [pc, #216]	; (2f8 <USR_Stack_Size+0xf8>)
 220:	2255      	movs	r2, #85	; 0x55
 222:	601a      	str	r2, [r3, #0]
  }
  PLLCON   &= ~0x01;                            /* Disable the PLL                                          */
 224:	4b33      	ldr	r3, [pc, #204]	; (2f4 <USR_Stack_Size+0xf4>)
 226:	4a33      	ldr	r2, [pc, #204]	; (2f4 <USR_Stack_Size+0xf4>)
 228:	6812      	ldr	r2, [r2, #0]
 22a:	2101      	movs	r1, #1
 22c:	438a      	bics	r2, r1
 22e:	601a      	str	r2, [r3, #0]
  PLLFEED   =  0xAA;                           	/* PLL register update sequence, 0xAA, 0x55                 */
 230:	4b31      	ldr	r3, [pc, #196]	; (2f8 <USR_Stack_Size+0xf8>)
 232:	22aa      	movs	r2, #170	; 0xaa
 234:	601a      	str	r2, [r3, #0]
  PLLFEED   =  0x55;
 236:	4b30      	ldr	r3, [pc, #192]	; (2f8 <USR_Stack_Size+0xf8>)
 238:	2255      	movs	r2, #85	; 0x55
 23a:	601a      	str	r2, [r3, #0]
  SCS      &= ~0x10;                         	/* OSCRANGE = 0, Main OSC is between 1 and 20 Mhz           */
 23c:	4b2f      	ldr	r3, [pc, #188]	; (2fc <USR_Stack_Size+0xfc>)
 23e:	4a2f      	ldr	r2, [pc, #188]	; (2fc <USR_Stack_Size+0xfc>)
 240:	6812      	ldr	r2, [r2, #0]
 242:	2110      	movs	r1, #16
 244:	438a      	bics	r2, r1
 246:	601a      	str	r2, [r3, #0]
  SCS      |=  0x20;                         	/* OSCEN = 1, Enable the main oscillator                    */
 248:	4b2c      	ldr	r3, [pc, #176]	; (2fc <USR_Stack_Size+0xfc>)
 24a:	4a2c      	ldr	r2, [pc, #176]	; (2fc <USR_Stack_Size+0xfc>)
 24c:	6812      	ldr	r2, [r2, #0]
 24e:	2120      	movs	r1, #32
 250:	430a      	orrs	r2, r1
 252:	601a      	str	r2, [r3, #0]
  while ((SCS &  0x40) == 0);
 254:	46c0      	nop			; (mov r8, r8)
 256:	4b29      	ldr	r3, [pc, #164]	; (2fc <USR_Stack_Size+0xfc>)
 258:	681a      	ldr	r2, [r3, #0]
 25a:	2340      	movs	r3, #64	; 0x40
 25c:	4013      	ands	r3, r2
 25e:	d0fa      	beq.n	256 <USR_Stack_Size+0x56>
  CLKSRCSEL = 0x01;                         	/* Select main OSC, 12MHz, as the PLL clock source          */
 260:	4b27      	ldr	r3, [pc, #156]	; (300 <USR_Stack_Size+0x100>)
 262:	2201      	movs	r2, #1
 264:	601a      	str	r2, [r3, #0]
  PLLCFG    = (24 << 0) | (1 << 16);         	/* Configure the PLL multiplier and divider                 */   
 266:	4b27      	ldr	r3, [pc, #156]	; (304 <USR_Stack_Size+0x104>)
 268:	4a27      	ldr	r2, [pc, #156]	; (308 <USR_Stack_Size+0x108>)
 26a:	601a      	str	r2, [r3, #0]
  PLLFEED   = 0xAA;                         	/* PLL register update sequence, 0xAA, 0x55                 */
 26c:	4b22      	ldr	r3, [pc, #136]	; (2f8 <USR_Stack_Size+0xf8>)
 26e:	22aa      	movs	r2, #170	; 0xaa
 270:	601a      	str	r2, [r3, #0]
  PLLFEED   = 0x55;
 272:	4b21      	ldr	r3, [pc, #132]	; (2f8 <USR_Stack_Size+0xf8>)
 274:	2255      	movs	r2, #85	; 0x55
 276:	601a      	str	r2, [r3, #0]
  PLLCON   |= 0x01;                        		/* Enable the PLL                                           */
 278:	4b1e      	ldr	r3, [pc, #120]	; (2f4 <USR_Stack_Size+0xf4>)
 27a:	4a1e      	ldr	r2, [pc, #120]	; (2f4 <USR_Stack_Size+0xf4>)
 27c:	6812      	ldr	r2, [r2, #0]
 27e:	2101      	movs	r1, #1
 280:	430a      	orrs	r2, r1
 282:	601a      	str	r2, [r3, #0]
  PLLFEED   = 0xAA;                        		/* PLL register update sequence, 0xAA, 0x55                 */
 284:	4b1c      	ldr	r3, [pc, #112]	; (2f8 <USR_Stack_Size+0xf8>)
 286:	22aa      	movs	r2, #170	; 0xaa
 288:	601a      	str	r2, [r3, #0]
  PLLFEED   = 0x55;
 28a:	4b1b      	ldr	r3, [pc, #108]	; (2f8 <USR_Stack_Size+0xf8>)
 28c:	2255      	movs	r2, #85	; 0x55
 28e:	601a      	str	r2, [r3, #0]
  CCLKCFG   = 3;                        		/* Configure the ARM Core Processor clock divider           */
 290:	4b1e      	ldr	r3, [pc, #120]	; (30c <USR_Stack_Size+0x10c>)
 292:	2203      	movs	r2, #3
 294:	601a      	str	r2, [r3, #0]
  USBCLKCFG = 5;                    			/* Configure the USB clock divider                          */
 296:	4b1e      	ldr	r3, [pc, #120]	; (310 <USR_Stack_Size+0x110>)
 298:	2205      	movs	r2, #5
 29a:	601a      	str	r2, [r3, #0]
  while ((PLLSTAT & 0x04000000) == 0);  
 29c:	46c0      	nop			; (mov r8, r8)
 29e:	4b14      	ldr	r3, [pc, #80]	; (2f0 <USR_Stack_Size+0xf0>)
 2a0:	681a      	ldr	r2, [r3, #0]
 2a2:	2380      	movs	r3, #128	; 0x80
 2a4:	04db      	lsls	r3, r3, #19
 2a6:	4013      	ands	r3, r2
 2a8:	d0f9      	beq.n	29e <USR_Stack_Size+0x9e>
  PCLKSEL0  = 0xAAAAAAAA;                     	/* Set peripheral clocks to be half of main clock           */
 2aa:	4b1a      	ldr	r3, [pc, #104]	; (314 <USR_Stack_Size+0x114>)
 2ac:	4a1a      	ldr	r2, [pc, #104]	; (318 <USR_Stack_Size+0x118>)
 2ae:	601a      	str	r2, [r3, #0]
  PCLKSEL1  = 0x22AAA8AA;
 2b0:	4b1a      	ldr	r3, [pc, #104]	; (31c <USR_Stack_Size+0x11c>)
 2b2:	4a1b      	ldr	r2, [pc, #108]	; (320 <USR_Stack_Size+0x120>)
 2b4:	601a      	str	r2, [r3, #0]
  PLLCON   |= 0x02;                         	/* Connect the PLL. The PLL is now the active clock source  */
 2b6:	4b0f      	ldr	r3, [pc, #60]	; (2f4 <USR_Stack_Size+0xf4>)
 2b8:	4a0e      	ldr	r2, [pc, #56]	; (2f4 <USR_Stack_Size+0xf4>)
 2ba:	6812      	ldr	r2, [r2, #0]
 2bc:	2102      	movs	r1, #2
 2be:	430a      	orrs	r2, r1
 2c0:	601a      	str	r2, [r3, #0]
  PLLFEED   = 0xAA;                          	/* PLL register update sequence, 0xAA, 0x55                 */
 2c2:	4b0d      	ldr	r3, [pc, #52]	; (2f8 <USR_Stack_Size+0xf8>)
 2c4:	22aa      	movs	r2, #170	; 0xaa
 2c6:	601a      	str	r2, [r3, #0]
  PLLFEED   = 0x55;
 2c8:	4b0b      	ldr	r3, [pc, #44]	; (2f8 <USR_Stack_Size+0xf8>)
 2ca:	2255      	movs	r2, #85	; 0x55
 2cc:	601a      	str	r2, [r3, #0]
  while ((PLLSTAT & 0x02000000) == 0);  
 2ce:	46c0      	nop			; (mov r8, r8)
 2d0:	4b07      	ldr	r3, [pc, #28]	; (2f0 <USR_Stack_Size+0xf0>)
 2d2:	681a      	ldr	r2, [r3, #0]
 2d4:	2380      	movs	r3, #128	; 0x80
 2d6:	049b      	lsls	r3, r3, #18
 2d8:	4013      	ands	r3, r2
 2da:	d0f9      	beq.n	2d0 <USR_Stack_Size+0xd0>
  PCLKSEL0 = 0x55555555;  		     			/* PCLK is the same as CCLK */
 2dc:	4b0d      	ldr	r3, [pc, #52]	; (314 <USR_Stack_Size+0x114>)
 2de:	4a11      	ldr	r2, [pc, #68]	; (324 <USR_Stack_Size+0x124>)
 2e0:	601a      	str	r2, [r3, #0]
  PCLKSEL1 = 0x55555555;  
 2e2:	4b0e      	ldr	r3, [pc, #56]	; (31c <USR_Stack_Size+0x11c>)
 2e4:	4a0f      	ldr	r2, [pc, #60]	; (324 <USR_Stack_Size+0x124>)
 2e6:	601a      	str	r2, [r3, #0]
}
 2e8:	46bd      	mov	sp, r7
 2ea:	bc80      	pop	{r7}
 2ec:	bc01      	pop	{r0}
 2ee:	4700      	bx	r0
 2f0:	e01fc088 	.word	0xe01fc088
 2f4:	e01fc080 	.word	0xe01fc080
 2f8:	e01fc08c 	.word	0xe01fc08c
 2fc:	e01fc1a0 	.word	0xe01fc1a0
 300:	e01fc10c 	.word	0xe01fc10c
 304:	e01fc084 	.word	0xe01fc084
 308:	00010018 	.word	0x00010018
 30c:	e01fc104 	.word	0xe01fc104
 310:	e01fc108 	.word	0xe01fc108
 314:	e01fc1a8 	.word	0xe01fc1a8
 318:	aaaaaaaa 	.word	0xaaaaaaaa
 31c:	e01fc1ac 	.word	0xe01fc1ac
 320:	22aaa8aa 	.word	0x22aaa8aa
 324:	55555555 	.word	0x55555555

00000328 <main>:

}		
/************************* main routine ************************************************************/

int main ()
{
 328:	b580      	push	{r7, lr}
 32a:	af00      	add	r7, sp, #0
	FIO3DIR=0xFFFFFFFF;
 32c:	4b16      	ldr	r3, [pc, #88]	; (388 <loop+0x44>)
 32e:	2201      	movs	r2, #1
 330:	4252      	negs	r2, r2
 332:	601a      	str	r2, [r3, #0]
	FIO4DIR=0x00;	
 334:	4b15      	ldr	r3, [pc, #84]	; (38c <loop+0x48>)
 336:	2200      	movs	r2, #0
 338:	601a      	str	r2, [r3, #0]
	init_timer(((72000000/100)-1));
 33a:	4b15      	ldr	r3, [pc, #84]	; (390 <loop+0x4c>)
 33c:	1c18      	adds	r0, r3, #0
 33e:	f000 f87b 	bl	438 <init_timer>
		2 cycles. There are 32 transfers. Hence there are totally 96 cycles
		per a sine cycle and possible atmost 4 cycles for branching. Hence,
		the total time per a sine cycle = 100 * cycle time
	*/
	
	asm("LDR	R0, =0xE006C000		@ Address of the DACR\n\t"
 342:	4814      	ldr	r0, [pc, #80]	; (394 <loop+0x50>)

00000344 <loop>:
 344:	217c      	movs	r1, #124	; 0x7c
 346:	6001      	str	r1, [r0, #0]
 348:	21ba      	movs	r1, #186	; 0xba
 34a:	6001      	str	r1, [r0, #0]
 34c:	21e7      	movs	r1, #231	; 0xe7
 34e:	6001      	str	r1, [r0, #0]
 350:	21f8      	movs	r1, #248	; 0xf8
 352:	6001      	str	r1, [r0, #0]
 354:	21e7      	movs	r1, #231	; 0xe7
 356:	6001      	str	r1, [r0, #0]
 358:	21ba      	movs	r1, #186	; 0xba
 35a:	6001      	str	r1, [r0, #0]
 35c:	217c      	movs	r1, #124	; 0x7c
 35e:	6001      	str	r1, [r0, #0]
 360:	217c      	movs	r1, #124	; 0x7c
 362:	6001      	str	r1, [r0, #0]
 364:	213e      	movs	r1, #62	; 0x3e
 366:	6001      	str	r1, [r0, #0]
 368:	2110      	movs	r1, #16
 36a:	6001      	str	r1, [r0, #0]
 36c:	2100      	movs	r1, #0
 36e:	6001      	str	r1, [r0, #0]
 370:	2110      	movs	r1, #16
 372:	6001      	str	r1, [r0, #0]
 374:	213e      	movs	r1, #62	; 0x3e
 376:	6001      	str	r1, [r0, #0]
 378:	e7e4      	b.n	344 <loop>
		"MOV	R1, #62\n\t "
		"STR	R1, [R0]\n\t"
		"	B loop"
		
	);
	return 0;
 37a:	2300      	movs	r3, #0
}
 37c:	1c18      	adds	r0, r3, #0
 37e:	46bd      	mov	sp, r7
 380:	bc80      	pop	{r7}
 382:	bc02      	pop	{r1}
 384:	4708      	bx	r1
 386:	46c0      	nop			; (mov r8, r8)
 388:	3fffc060 	.word	0x3fffc060
 38c:	3fffc080 	.word	0x3fffc080
 390:	000afc7f 	.word	0x000afc7f
 394:	e006c000 	.word	0xe006c000

00000398 <install_irq>:
**						interrupt priority
** Returned value:		true or false, return false if IntNum is out of range
** 
******************************************************************************/
int install_irq( int IntNumber, void *HandlerAddr, int Priority )
{
 398:	b580      	push	{r7, lr}
 39a:	b086      	sub	sp, #24
 39c:	af00      	add	r7, sp, #0
 39e:	60f8      	str	r0, [r7, #12]
 3a0:	60b9      	str	r1, [r7, #8]
 3a2:	607a      	str	r2, [r7, #4]
    int *vect_addr;
    int *vect_cntl;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
 3a4:	4b14      	ldr	r3, [pc, #80]	; (3f8 <install_irq+0x60>)
 3a6:	2101      	movs	r1, #1
 3a8:	68fa      	ldr	r2, [r7, #12]
 3aa:	1c08      	adds	r0, r1, #0
 3ac:	4090      	lsls	r0, r2
 3ae:	1c02      	adds	r2, r0, #0
 3b0:	601a      	str	r2, [r3, #0]
    if ( IntNumber >= 32 )
 3b2:	68fb      	ldr	r3, [r7, #12]
 3b4:	2b1f      	cmp	r3, #31
 3b6:	dd01      	ble.n	3bc <install_irq+0x24>
    {
		return ( FALSE );
 3b8:	2300      	movs	r3, #0
 3ba:	e017      	b.n	3ec <install_irq+0x54>
    }
    else
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (int *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
 3bc:	68fb      	ldr	r3, [r7, #12]
 3be:	4a0f      	ldr	r2, [pc, #60]	; (3fc <install_irq+0x64>)
 3c0:	189b      	adds	r3, r3, r2
 3c2:	009b      	lsls	r3, r3, #2
 3c4:	613b      	str	r3, [r7, #16]
		vect_cntl = (int *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + IntNumber*4);
 3c6:	68fb      	ldr	r3, [r7, #12]
 3c8:	480d      	ldr	r0, [pc, #52]	; (400 <Stack_Size>)
 3ca:	181b      	adds	r3, r3, r0
 3cc:	009b      	lsls	r3, r3, #2
 3ce:	617b      	str	r3, [r7, #20]
		*vect_addr = (int)HandlerAddr;	/* set interrupt vector */
 3d0:	68ba      	ldr	r2, [r7, #8]
 3d2:	693b      	ldr	r3, [r7, #16]
 3d4:	601a      	str	r2, [r3, #0]
		*vect_cntl = Priority;
 3d6:	697b      	ldr	r3, [r7, #20]
 3d8:	687a      	ldr	r2, [r7, #4]
 3da:	601a      	str	r2, [r3, #0]
		VICIntEnable = 1 << IntNumber;	/* Enable Interrupt */
 3dc:	4b09      	ldr	r3, [pc, #36]	; (404 <Stack_Size+0x4>)
 3de:	2101      	movs	r1, #1
 3e0:	68fa      	ldr	r2, [r7, #12]
 3e2:	1c08      	adds	r0, r1, #0
 3e4:	4090      	lsls	r0, r2
 3e6:	1c02      	adds	r2, r0, #0
 3e8:	601a      	str	r2, [r3, #0]
		return( TRUE );
 3ea:	2301      	movs	r3, #1
    }
}
 3ec:	1c18      	adds	r0, r3, #0
 3ee:	46bd      	mov	sp, r7
 3f0:	b006      	add	sp, #24
 3f2:	bc80      	pop	{r7}
 3f4:	bc02      	pop	{r1}
 3f6:	4708      	bx	r1
 3f8:	fffff014 	.word	0xfffff014
 3fc:	3ffffc40 	.word	0x3ffffc40
 400:	3ffffc80 	.word	0x3ffffc80
 404:	fffff010 	.word	0xfffff010

00000408 <Timer0Handler>:
******************************************************************************/
#ifdef __GNUC__
void Timer0Handler (void); // avoid missing proto warning - mthomas
#endif
void Timer0Handler (void) __irq 
{  
 408:	b580      	push	{r7, lr}
 40a:	af00      	add	r7, sp, #0
    T0IR = 1;			/* clear interrupt flag */
 40c:	4b07      	ldr	r3, [pc, #28]	; (42c <Timer0Handler+0x24>)
 40e:	2201      	movs	r2, #1
 410:	601a      	str	r2, [r3, #0]
    IENABLE;			/* handles nested interrupt */

    timer_counter++;
 412:	4b07      	ldr	r3, [pc, #28]	; (430 <Timer0Handler+0x28>)
 414:	681b      	ldr	r3, [r3, #0]
 416:	1c5a      	adds	r2, r3, #1
 418:	4b05      	ldr	r3, [pc, #20]	; (430 <Timer0Handler+0x28>)
 41a:	601a      	str	r2, [r3, #0]

    IDISABLE;
    VICVectAddr = 0;		/* Acknowledge Interrupt */
 41c:	4b05      	ldr	r3, [pc, #20]	; (434 <Timer0Handler+0x2c>)
 41e:	2200      	movs	r2, #0
 420:	601a      	str	r2, [r3, #0]
}
 422:	46bd      	mov	sp, r7
 424:	bc80      	pop	{r7}
 426:	bc01      	pop	{r0}
 428:	4700      	bx	r0
 42a:	46c0      	nop			; (mov r8, r8)
 42c:	e0004000 	.word	0xe0004000
 430:	40000074 	.word	0x40000074
 434:	ffffff00 	.word	0xffffff00

00000438 <init_timer>:
** Returned value:		true or false, if the interrupt handler can't be
**						installed, return false.
** 
******************************************************************************/
int init_timer ( int TimerInterval ) 
{
 438:	b580      	push	{r7, lr}
 43a:	b082      	sub	sp, #8
 43c:	af00      	add	r7, sp, #0
 43e:	6078      	str	r0, [r7, #4]
    timer_counter = 0;
 440:	4b0c      	ldr	r3, [pc, #48]	; (474 <init_timer+0x3c>)
 442:	2200      	movs	r2, #0
 444:	601a      	str	r2, [r3, #0]
    T0MR0 = TimerInterval;
 446:	4b0c      	ldr	r3, [pc, #48]	; (478 <init_timer+0x40>)
 448:	687a      	ldr	r2, [r7, #4]
 44a:	601a      	str	r2, [r3, #0]
    T0MCR = 3;				/* Interrupt and Reset on MR0*/ 
 44c:	4b0b      	ldr	r3, [pc, #44]	; (47c <init_timer+0x44>)
 44e:	2203      	movs	r2, #3
 450:	601a      	str	r2, [r3, #0]
    if ( install_irq( 4, (void *)Timer0Handler, 0x01 ) == FALSE )
 452:	4b0b      	ldr	r3, [pc, #44]	; (480 <init_timer+0x48>)
 454:	2004      	movs	r0, #4
 456:	1c19      	adds	r1, r3, #0
 458:	2201      	movs	r2, #1
 45a:	f7ff ff9d 	bl	398 <install_irq>
 45e:	1c03      	adds	r3, r0, #0
 460:	d101      	bne.n	466 <init_timer+0x2e>
    {
		return (FALSE);
 462:	2300      	movs	r3, #0
 464:	e000      	b.n	468 <init_timer+0x30>
    }
   else
    {
		return (TRUE);
 466:	2301      	movs	r3, #1
    }
}
 468:	1c18      	adds	r0, r3, #0
 46a:	46bd      	mov	sp, r7
 46c:	b002      	add	sp, #8
 46e:	bc80      	pop	{r7}
 470:	bc02      	pop	{r1}
 472:	4708      	bx	r1
 474:	40000074 	.word	0x40000074
 478:	e0004018 	.word	0xe0004018
 47c:	e0004014 	.word	0xe0004014
 480:	00000409 	.word	0x00000409
